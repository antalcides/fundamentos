%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Package pgfplots.sty documentation. 
%
% Copyright 2007-2009 by Christian Feuersaenger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{pgfplots.preamble.tex}

\usepackage{array}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{eurosym}
\usepackage{multirow}

\pgfqkeys{/codeexample}{%
	every codeexample/.style={
		width=4cm,
		/pgfplots/every axis/.append style={legend style={fill=graphicbackground}}
	},
	narrow/.style={width=7cm},
	tabsize=4,
}

\pgfkeys{/pgfmanual/gray key prefixes/.add={/pgfplots/table/,/pgf/number format/,}{}}

\makeatletter
\pgfkeys{%
	/codeexample/prettyprint/key name with handler/.code 2 args={%
		\gdef\pgfplotstablemanualautocheck{}%
		\foreach \special in {columns,create on use,alias,display columns}{%
			\expandafter\pgfutil@in@\expandafter{\special/}{#1}%
			\ifpgfutil@in@
				\xdef\pgfplotstablemanualautocheck{\special}%
				\breakforeach
			\fi
		}%
		\ifx\pgfplotstablemanualautocheck\pgfutil@empty%
			\pgfmanualpdfref{#1}{#1}/\pgfmanualpdfref{/handlers/#2}{#2}%
		\else
			\expandafter\def\expandafter\temp\expandafter##\expandafter1\pgfplotstablemanualautocheck/##2\relax{%
				\pgfmanualpdfref
					{/pgfplots/table/\pgfplotstablemanualautocheck}%
					{##1\pgfplotstablemanualautocheck/}%
				##2/%
				\pgfmanualpdfref{/handlers/#2}{#2}%
			}%
			\temp#1\relax
		\fi
	},
	/pdflinks/search key prefixes in/.add={/pgf/number format/,}{,/pgfplots/table/create col/},
	/pdflinks/show labels=false,
}
\makeatother

\pgfplotstableset{
	%debug=true,
	begin table=\begin{tabular}[b],
}

\title{%
	Manual for Package \PGFPlotstable\\
	{\small Component of \PGFPlots, Version \pgfplotsversion}\\
	{\small\href{http://sourceforge.net/projects/pgfplots}{http://sourceforge.net/projects/pgfplots}}}

\begin{document}
\maketitle
\begin{abstract}%
	This package reads tab-separated numerical tables from input and generates code for pretty-printed \LaTeX-tabulars. It rounds to the desired precision and prints it in different number formatting styles.
\end{abstract}
\tableofcontents
\section{Introduction}
\PGFPlotstable\ is a lightweight sub-package of \PGFPlots\ which employs its table input methods and the number formatting techniques to convert tab-separated tables into tabulars.

Its input is a text file containing space separated rows, possibly starting with column names. Its output is a \LaTeX\ tabular\footnote{Please see the remarks in section~\ref{sec:pgfplotstable:context} for plain \TeX\ and Con\TeX t.} which contains selected columns of the text table, rounded to the desired precision, printed in the desired number format (fixed point, integer, scientific etc.).

It is used with
% NO GALLERY
\begin{codeexample}[code only]
\usepackage{pgfplotstable}
% recommended:
%\usepackage{booktabs}
%\usepackage{array}
%\usepackage{colortbl}
\end{codeexample}
\noindent and requires \PGFPlots\ and \PGF\ $ \ge 2.00$ installed.

\begin{command}{\pgfplotstableset\marg{key-value-options}}
	The user interface of this package is based on key-value-options. They determine what to display, how to format and what to compute.
	
	Key-value pairs can be set in two ways:
	\begin{enumerate}
		\item As default settings for the complete document (or maybe a part of the document), using |\pgfplotstableset|\marg{options}. For example, the document's preamble may contain
% NO GALLERY
\begin{codeexample}[code only]
\pgfplotstableset{fixed zerofill,precision=3}
\end{codeexample}
			to configure a precision of $3$ digits after the period, including zeros to get exactly $3$ digits for all fixed point numbers.
		\item As option which affects just a single table. This is provided as optional argument to the respective table typesetting command, for example |\pgfplotstabletypeset|\oarg{options}\marg{file}.
	\end{enumerate}
	Both ways are shown in the examples below.

	Knowledge of |pgfkeys| is useful for a deeper insight into this package, as |/.style|, |/.append style| etc. are specific to |pgfkeys|. Please refer to the \PGF\ manual,~\cite[section pgfkeys]{tikz} if you want a deeper insight into  |pgfkeys|. Otherwise, simply skip over to the examples provided in this document.

	You will find key prefixes |/pgfplots/table/| and |/pgf/number format/|. These prefixes can be skipped if they are used in \PGFPlotstable; they belong to the ``default key path'' of |pgfkeys|.
\end{command}

\section{Loading and Displaying data}
\subsection{Text Table Input Format}
\PGFPlotstable\ works with plain text file tables in which entries (``cells'') are separated by a separation character. The initial separation character is ``white space'' which means ``at least one space or tab'' (see option |col sep| below). Those tables can have a header line which contains column names and most other columns typically contain numerical data.

\noindent The following listing shows |pgfplotstable.example1.dat| and is used often throughout this documentation.
\begin{codeexample}[code only]
# Convergence results
# fictional source, generated 2008
level    dof      error1            error2   info     grad(log(dof),log(error2)) quot(error1)      
1        4        2.50000000e-01    7.57858283e-01    48       0                   0      
2        16       6.25000000e-02    5.00000000e-01    25       -3.00000000e-01   4        
3        64       1.56250000e-02    2.87174589e-01    41       -3.99999999e-01   4        
4        256      3.90625000e-03    1.43587294e-01    8        -5.00000003e-01   4        
5        1024     9.76562500e-04    4.41941738e-02    22       -8.49999999e-01   4        
6        4096     2.44140625e-04    1.69802322e-02    46       -6.90000001e-01   4        
7        16384    6.10351562e-05    8.20091159e-03    40       -5.24999999e-01   4        
8        65536    1.52587891e-05    3.90625000e-03    48       -5.35000000e-01   3.99999999e+00    
9        262144   3.81469727e-06    1.95312500e-03    33       -5.00000000e-01   4.00000001e+00    
10       1048576  9.53674316e-07    9.76562500e-04    2        -5.00000000e-01   4.00000001e+00    
\end{codeexample}
Lines starting with `|%|' or `|#|' are considered to be comment lines and are ignored.

There is future support for a second header line which must start with `|$flags |' (the space is obligatory, even if the column separator is \emph{not} space!). Currently, such a line is ignored. It may be used to provide number formatting options like precision and number format.

\begin{command}{\pgfplotstabletypeset\oarg{optional arguments}\marg{file name {\normalfont or} \textbackslash macro {\normalfont or} inline table}}
	Loads (or acquires) a table and typesets it using the current configuration of number formats and table options.

	In case the first argument is a file name, the table will be loaded from disk. If it is an already loaded table (see |\pgfplotstableread| or |\pgfplotstablenew|), it will be used. Otherwise, if it is inline table data, this data will be parsed just as if it would have been found in a file (see |\pgfplotstableread|).
{
	% allow to typeset the example. I couldn't get the \catcodes
	% correctly...
	\pgfplotstableset{
		/codeexample/newline=\noexpand\\,
		row sep=\\,
	}%
\begin{codeexample}[]
\pgfplotstabletypeset[sci zerofill]{
	a b
	5000 1.234e5
	6000 1.631e5
	7000 2.1013e5
	9000 1000000
}
\end{codeexample}
}%


\begin{codeexample}[]
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}

	\noindent The configuration can be customized with \meta{optional arguments}. Configuration can be done for the complete table or for particular columns (or rows).

\begin{codeexample}[]
\pgfplotstableset{% global config, for example in the preamble
	% these columns/<colname>/.style={<options>} things define a style
	% which applies to <colname> only.
	columns/dof/.style={int detect,column type=r,column name=\textsc{Dof}},
	columns/error1/.style={
		sci,sci zerofill,sci sep align,precision=1,sci superscript,
		column name=$e_1$,
	},
	columns/error2/.style={
		sci,sci zerofill,sci sep align,precision=2,sci 10e,
		column name=$e_2$,
	},
	columns/{grad(log(dof),log(error2))}/.style={
		string replace={0}{}, % erase '0'
		column name={$\nabla e_2$},
		dec sep align,
	},
	columns/{quot(error1)}/.style={
		string replace={0}{}, % erase '0'
		column name={$\frac{e_1^{(n)}}{e_1^{(n-1)}}$}
	},
	empty cells with={--}, % replace empty cells with '--'
	every head row/.style={before row=\toprule,after row=\midrule},
	every last row/.style={after row=\bottomrule}
}
\pgfplotstabletypeset[ % local config, applies only for this table
	1000 sep={\,},
	columns/info/.style={
		fixed,fixed zerofill,precision=1,showpos,
		column type=r,
	}
]
{pgfplotstable.example1.dat}
\end{codeexample}
\noindent All of these options are explained in all detail in the following sections. 

You may also use a similar input format as for tabular environment:
\begin{codeexample}[width=8cm]
\pgfplotstabletypeset
	[col sep=&,row sep=\\,sci zerofill]
{
	level &  dof &    error \\
	1 &      4 &      2.50000000e-01 \\
	2 &      16 &     6.25000000e-02 \\
	3 &      64 &     1.56250000e-02 \\
	4 &      256 &    3.90625000e-03 \\
	5 &      1024 &   9.76562500e-04 \\
	6 &      4096 &   2.44140625e-04 \\
	7 &      16384 &  6.10351562e-05 \\
	8 &      65536 &  1.52587891e-05 \\
	9 &      262144 & 3.81469727e-06 \\
	10 &     1048576 &9.53674316e-07 \\
}
\end{codeexample}


Technical note: every opened file will be protocolled into your log file.
\end{command}

\begin{command}{\pgfplotstabletypesetfile\oarg{optional arguments}\marg{file name}}
	Loads the table \marg{file name} and typesets it. As of \PGFPlotstable\ 1.2, this command is an alias to |\pgfplotstabletypeset|, that means the first argument can be either a file name or an already loaded table.
\end{command}


\begin{commandlist}{%
	\pgfplotstableread\marg{file name}\marg{\textbackslash macro},
	\pgfplotstableread\marg{inline table}\marg{\textbackslash macro}}
	Loads a table into the \TeX-macro \meta{\textbackslash macro}. This macro will store the table as internal structure and can be used several times.
\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}\loadedtable
\pgfplotstabletypeset[columns={dof,error1}]\loadedtable
\hspace{2cm}
\pgfplotstabletypeset[columns={dof,error2}]\loadedtable
\end{codeexample}
	The first argument can be either a \meta{file name} as in the example here. It is also possible to provide the table data directly:
\begin{codeexample}[code only]
% Alternative: inline table data:
\pgfplotstableread{
level   dof     error1  error2  info    grad(log(dof),log(error2))      quot(error1)    
1       4       2.50000000e-01  7.57858283e-01  48      0                   0   
2       16      6.25000000e-02  5.00000000e-01  25      -3.00000000e-01 4       
3       64      1.56250000e-02  2.87174589e-01  41      -3.99999999e-01 4       
4       256     3.90625000e-03  1.43587294e-01  8       -5.00000003e-01 4       
5       1024    9.76562500e-04  4.41941738e-02  22      -8.49999999e-01 4       
6       4096    2.44140625e-04  1.69802322e-02  46      -6.90000001e-01 4       
7       16384   6.10351562e-05  8.20091159e-03  40      -5.24999999e-01 4       
8       65536   1.52587891e-05  3.90625000e-03  48      -5.35000000e-01 3.99999999e+00  
9       262144  3.81469727e-06  1.95312500e-03  33      -5.00000000e-01 4.00000001e+00  
10      1048576 9.53674316e-07  9.76562500e-04  2       -5.00000000e-01 4.00000001e+00  
}\loadedtable
% can be used as above:
\pgfplotstabletypeset[columns={dof,error1}]\loadedtable
\hspace{2cm}
\pgfplotstabletypeset[columns={dof,error2}]\loadedtable
\end{codeexample}
	It is checked automatically whether the first argument contains inline data or a file name.

	The check whether the first argument is inline data or a file name works as follows: if |format=auto|, the first argument is considered to be a file name unless it contains the |row sep| character (see |row sep|). If |format=inline|, it is always considered to be inline data. If |format=file|, it is a file name.

	\paragraph{Special cases and more details:}
	\begin{itemize}
		\item The inline data format is ``fragile''. If you experience problems, terminate your tables with `|\\|' combined with |row sep=\\| (the docs for |row sep| contain alternative ways and more explanation).
		\item There are variants of this command which do not really built up a struct but which report every line to a ``listener''. There is also a struct which avoids protection by \TeX\ scopes. In case you need such things, consider reading the source code comments.
		\item Technical note: every opened file will be protocolled into your log file.
		\item Note: avoid using `|\table|' as name, it conflicts with |\begin{table}| of \LaTeX.
	\end{itemize}
\end{commandlist}

\begin{key}{/pgfplots/table/col sep=\mchoice{space,tab,comma,semicolon,colon,braces,\&,ampersand} (initially space)}
	Specifies the column separation character for table reading. The initial choice, |space| means ``at least one white space''. White spaces are tab stops or spaces (newlines always delimit lines).

	For example, the file |pgfplotstable.example1.csv| uses commas as separation characters.
\begin{codeexample}[code only]
# Convergence results
# fictional source  generated 2008
level,dof,error1,error2,info,{grad(log(dof),log(error2))},quot(error1)
1,9,2.50000000e-01,7.57858283e-01,48,0,0
2,25,6.25000000e-02,5.00000000e-01,25,-1.35691545e+00,4
3,81,1.56250000e-02,2.87174589e-01,41,-1.17924958e+00,4
4,289,3.90625000e-03,1.43587294e-01,8,-1.08987331e+00,4
5,1089,9.76562500e-04,4.41941738e-02,22,-1.04500712e+00,4
6,4225,2.44140625e-04,1.69802322e-02,46,-1.02252239e+00,4
7,16641,6.10351562e-05,8.20091159e-03,40,-1.01126607e+00,4
8,66049,1.52587891e-05,3.90625000e-03,48,-1.00563427e+00,3.99999999e+00
9,263169,3.81469727e-06,1.95312500e-03,33,-1.00281745e+00,4.00000001e+00
10,1050625,9.53674316e-07,9.76562500e-04,2,-1.00140880e+00,4.00000001e+00
\end{codeexample}
	Thus, we need to specify |col sep=comma| when we read it.
\begin{codeexample}[]
\pgfplotstabletypeset[col sep=comma]{pgfplotstable.example1.csv}
\end{codeexample}
	You may call |\pgfplotstableset{col sep=comma}| once in your preamble if all your tables use commas as column separator.

	Please note that if cell entries (for example column names) contain the separation character, you need to enclose the column entry in \emph{braces}: |{grad(log(dof),log(error2)}|. If you want to use unmatched braces, you need to write a backslash before the brace. For example the name `|column{withbrace|' needs to be written as `|column\{withbrace|'. 

	For |col sep|$\neq$|space|, spaces will be considered to be part of the argument (there is no trimming). However, (as usual in \TeX), multiple successive spaces and tabs are summarized into white space. Of course, if |col sep=tab|, tabs are the column separators and will be treated specially.
	
	Furthermore, if you need empty cells in case |col sep=space|, you have to provide |{}| to delimit such a cell since |col sep=space| uses \emph{at least} one white space (consuming all following ones).

	The value |col sep=braces| is special since it actually uses two separation characters. Every single cell entry is delimited by an opening and a closing brace, \marg{entry}, for this choice. Furthermore, any white spaces (spaces and tabs) between cell entries are \emph{skipped} in case |braces| until the next \marg{entry} is found.
	
	A further speciality of |col sep=braces| is that it has support for \emph{multi-line} cells: everything within balanced braces is considered to be part of a cell. This includes newlines\footnote{This treatment of newlines within balanced braces actually applies to every other column separator as well (it is a \TeX\ readline feature). In other words: you \emph{can} have multi line cells for every column separator if you enclose them in balanced curly braces. However, \texttt{col sep=braces} has the special treatment that end-of-line counts as white space character; for every other \texttt{col sep} value, this white space is suppressed to remove spurious spaces.}.

	The |col sep=&| case (probably together with |row sep=\\|) allows to read tables as you'd usually type them in \LaTeX. This will automatically enable |trim cells|.
\end{key}

\begin{key}{/pgfplots/table/trim cells=\mchoice{true,false} (initially false)}
	If enabled, leading and trailing white spaces will be removed while tables are read.

	This might be necessary if you have |col sep|$\neq$|space| but your cells contain spaces. It will be activated automatically for |col sep=&|.
\end{key}

\begin{key}{/pgfplots/table/header=\mchoice{true,false,has colnames} (initially true)}
	Configures if column names shall be identified automatically during input operations.

	The first non-comment line \emph{can} be a header which contains column names. The |header| key configures how to detect if that is really the case. 
	
	The choice \declaretext{true} enables auto--detection of column names: If the first non-comment line contains at least one non-numerical entry (for example `|a name|'), each entry in this line is supposed to be a column name. If the first non-comment line contains only numerical data, it is used as data row. In this case, column indices will be assigned as column ``names''.

	The choice \declaretext{false} is identical to this last case, i.e.\ even if the first line contains strings, they won't be recognised as column names.

	Finally, the choice \declaretext{has colnames} is the opposite of |false|: it assumes that the first non--comment line \emph{contains} column names. In other words: even if only numbers are contained in the first line, they are considered to be column \emph{names}.
\end{key}

\begin{pgfplotskey}{table/format=\mchoice{auto,inline,file} (initially auto)}
	Configures the format expected as first argument for |\pgfplotstableread|\marg{input}.
	
	The choice \declaretext{inline} expects the table data directly as argument where rows are separated by |row sep|. Inline data is ``fragile'', because \TeX\ may consume end--of--line characters (or |col sep| characters). See |row sep| for details.

	The choice \declaretext{file} expects a file name.

	The choice \declaretext{auto} searches for a |row sep| in the first argument supplied to |\pgfplotstableread|. If a |row sep| has been found, it is inline data, otherwise it is a file name.
\end{pgfplotskey}
\begin{pgfplotskey}{table/row sep=\mchoice{newline,\string\\} (initially newline)}
	Configures the character to separate rows of the inline table data format (see |format=inline|).

	The choice \declaretext{newline} uses the end of line as it appears in the table data (i.e.\ the input file or any inline table data).

	The choice \declaretext{\string\\} uses `|\\|' to indicate the end of a row.

	Note that \declaretext{newline} for inline table data is ``fragile'': you can't provide such data inside of \TeX\ macros (this does not apply to input files). Whenever you experience problems, proceed as follows:
	\begin{enumerate}
		\item First possibility: call |\pgfplotstableread|\marg{data}|\yourmacro| \emph{outside} of any macro declaration.
		\item Use |row sep=\\|.
	\end{enumerate}
	The same applies if you experience problems with inline data and special |col sep| choices (like |col sep=tab|).

	The reasons for such problems is that \TeX\ scans the macro bodies and replaces newlines by white spaces. It does other substitutions of this sort as well, and these substitutions can't be undone (maybe not even found).
\end{pgfplotskey}

\begin{key}{/pgfplots/table/ignore chars=\marg{comma-separated-list} (initially empty)}
	Allows to define an ``ignore list'' for single characters. Any characters found in an input file which occur also in \meta{comma-separated-list} will silently by thrown away. The processing is exactly the same as if you did not write them at all in the first place.

	For example, suppose we are given |pgfplotstable.example5.dat| with
\lstinputlisting[basicstyle=\ttfamily\footnotesize]{pgfplotstable.example5.dat}

	\noindent then, we can ignore several of the characters by writing
\begin{codeexample}[]
\pgfplotstabletypeset
	[col sep=comma,ignore chars={(,),\ ,\#}]
	{pgfplotstable.example5.dat}
\end{codeexample}

	The \meta{comma-separated-list} should contain exactly one character in each list element, and the single characters should be separated by commas. Some special characters like commas, white spaces, hashes, percents or backslashes need to be escaped by prefixing them with a backslash. 

	Besides normal characters, it is also supported to eliminate any binary code from your input files. For example, suppose you have binary characters of code |0x01| (hex notation) in your files. Then, use
\begin{codeexample}[code only]
\pgfplotstableset{ignore chars={\^^01}}
\end{codeexample}
	\noindent to eliminate them silently. The |^^|\meta{digit}\meta{digit} notation is a \TeX\ feature to provide characters in hexadecimal encoding where \meta{digit} is one of |0123456789abcdef|. I don't know if the backslash in |\^^01| is always necessary, try it out. There is also a character based syntax, in which |\^^M| is \meta{newline} and |\^^I| is \meta{tab}. Refer to~\cite{texbook} for more details.

	Note that after stripping all these characters, the input table must be valid -- it should still contain column separators and balanced columns.

	This setting applies to |\addplot table| and |\addplot file| for \PGFPlots\ as well.

	Note that |ignore chars| is ``fragile'' when it is applied to |format=inline| or |format=auto|. Consider |format=file| if you experience problems\footnote{See also |row\ sep| for more information about dealing with fragile inline tables formats.}.
\end{key}

\begin{key}{/pgfplots/table/white space chars=\marg{comma-separated-list} (initially empty)}
	Allows to define a list of single characters which are actually treated like white spaces (in addition to tabs and spaces). It might be useful in order to get more than one column separator character.

	The |white space chars| list is used in exactly the same way as |ignore chars|, and the same remarks as above apply as well.
\end{key}

\subsection{Selecting Columns and their Appearance Styles}
\begin{key}{/pgfplots/table/columns=\marg{comma-separated-list}}
	Selects particular columns the table. If this option is empty (has not been provided), all available columns will be selected.

	Inside of \marg{comma-separated-list}, column names as they appear in the table's header are expected. If there is no header, simply use column indices. If there are column names, the special syntax |[index]|\meta{integer} can be used to select columns by index. The first column has index~$0$.
\begin{codeexample}[]
\pgfplotstabletypeset[columns={dof,level,[index]4}]{pgfplotstable.example1.dat}
\end{codeexample}
	
	The special |pgfkeys| feature |\pgfplotstableset{columns/.add={}{,a further col}}| allows to \emph{append} a value, in this case `|,a further col|' to the actual value. See |/.add| for details.
\end{key}

\begin{pgfplotstablealiaskey}
	Assigns the new name \meta{col name} for the column denoted by \meta{real col name}. Afterwards, accessing \meta{col name} will use the data associated with column \meta{real col name}.
\begin{codeexample}[]
% in preamble:
\pgfplotstableset{
	alias/newname/.initial=b,
}%
%
% in document:
\pgfplotstabletypeset[
	row sep=\\,
	columns={a,newname},% access to `newname' is the same as to `b'
]{
	a b\\
	1 2\\
	3 4\\
	5 6\\
}%
\end{codeexample}
	You can use |columns/|\meta{col name}|/.style| to assign styles for the alias, not for the original column name.

	If there exists both an alias and a column of the same name, the column name will be preferred. Furthermore, if there exists a |create on use| statement with the same name, this one will also be preferred.

	In case \meta{col name} contains characters which are required for key settings, you need to use braces around it: ``|alias/{name=wi/th,special}/.initial={othername}|''.

	This key is used whenever columns are queries, it applies also to the |\addplot table| statement of \PGFPlots.
\end{pgfplotstablealiaskey}

\begin{pgfplotstablecolumnkey}
	Sets all options in \marg{key-value-list} exclusively for \marg{column name}.

\begin{codeexample}[]
\pgfplotstabletypeset[
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/error2/.style={
		column name=$A$,
		sci,sci zerofill,sci subscript,
		precision=2},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}
	}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	If your column name contains commas `|,|', slashes `|/|' or equal signs `|=|', you need to enclose the column name in braces.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	If your tables don't have column names, you can simply use integer indices instead of \marg{column name} to refer to columns. If you have column names, you can't set column styles using indices.
\end{pgfplotstablecolumnkey}

\begin{pgfplotstabledisplaycolumnkey}
	Applies all options in \marg{key-value-list} exclusively to the column which will appear at position \meta{index} in the output table.

	In contrast to the |table/columns/|\meta{name} styles, this option refers to the output table instead of the input table. Since the output table has no unique column name, you can only access columns by index.

	Indexing starts with~$\meta{index}=0$.

	Display column styles override input column styles.
\end{pgfplotstabledisplaycolumnkey}

\begin{stylekey}{/pgfplots/table/every col no \meta{index}}
	A style which is identical with |display columns/|\meta{index}: it applies exclusively to the column at position \meta{index} in the output table.

	See |display columns/|\meta{index} for details.
\end{stylekey}

\begin{key}{/pgfplots/table/column type=\marg{tabular column type} (initially c)}
	Contains the column type for |tabular|. 
	
	If all column types are empty, the complete argument is skipped (assuming that no |tabular| environment is generated).

	Use |\pgfplotstableset{column type/.add=|\marg{before}\marg{after}|}| to \emph{modify} a value instead of overwriting it. The |/.add| key handler works for other options as well.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
	columns={dof,error1,info},
	column type/.add={|}{}% results in '|c'
]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{key}

\begin{key}{/pgfplots/table/column name=\marg{\TeX\ display column name}}
	Sets the column name in the current context.

	It is advisable to provide this option inside of a column-specific style, i.e. using
	
	|columns/|\marg{lowlevel colname}|/.style={column name=|\marg{\TeX\ display column name}|}| .
\end{key}

\begin{codekey}{/pgfplots/table/assign column name}
	Allows to \emph{modify} the value of |column name|.
	
	Argument |#1| is the current column name, that means after
	evaluation of |column name|. After |assign column| name, a new (possibly modified) value for |column name| should be set.
	
	That means you can use |column name| to assign the name as such
	and |assign column name| to generate final \TeX\ code (for example to insert |\multicolumn{1}{c}{#1}|).

	Default is empty which means no change.
\end{codekey}

\begin{stylekey}{/pgfplots/table/multicolumn names=\marg{tabular column type} (initially c)}
	A style which typesets each column name using a |\multicolumn{1}|\marg{tabular column type}\marg{the column name} statement.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/dec sep align=\marg{header column type} (initially c)}
	A style which aligns numerical columns at the decimal separator.

	The first argument determines the alignment of the header column. 

	Please note that you need |\usepackage{array}| for this style.
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[
	columns={dof,error1,error2,info,{grad(log(dof),log(error2))}},
	columns/error1/.style={dec sep align},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/info/.style={fixed,dec sep align},
	columns/{grad(log(dof),log(error2))}/.style={fixed,dec sep align}
]
	{pgfplotstable.example1.dat}
\end{codeexample}

	Or with comma as decimal separator:
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[
	use comma,
	columns={dof,error1,error2,info,{grad(log(dof),log(error2))}},
	columns/error1/.style={dec sep align},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/info/.style={fixed,dec sep align},
	columns/{grad(log(dof),log(error2))}/.style={fixed,dec sep align}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	It may be advisable to use |fixed zerofill| and/or |sci zerofill| to force at least one digit after the decimal separator to improve placement of exponents:
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[
	use comma,
	columns={dof,error1,error2,info,{grad(log(dof),log(error2))}},
	columns/error1/.style={dec sep align,sci zerofill},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/info/.style={fixed,dec sep align},
	columns/{grad(log(dof),log(error2))}/.style={fixed,dec sep align,fixed zerofill}
]
	{pgfplotstable.example1.dat}
\end{codeexample}

	The style |dec sep align| actually introduces two new |tabular| columns\footnote{Unfortunately, \texttt{dec sep align} is currently not very flexible when it comes to column type modifications. In particular, it is not possible to use colored columns or cells in conjunction with \texttt{dec sep align}. The \texttt{\textbackslash rowcolor} command works properly; the color hangover introduced by \texttt{colortbl} is adjusted automatically.}, namely |r@{}l|. It introduces multicolumns for column names accordingly and handles numbers which do not have a decimal separator. 
	

	Note that for fixed point numbers, it might be an alternative to use |fixed zerofill| combined with |column type=r| to get a similar effect.

	Please note that this style overwrites |column type|, |assign cell content| and some number formatting settings.
\end{stylekey}

%--------------------------------------------------
% FIXME : doesn't really work as intended:
% \begin{stylekey}{/pgfplots/table/dec sep align/no unbounded}
% 	Changes the internal processing of |dec sep align| such that unbounded values like $NaN$ and $\pm \infty$ will be aligned in exactly the same way as the column name.
% 
% 	This avoids funny spacing around unbounded coordinates when used with |dec sep align|.
 
% NO GALLERY
% \begin{codeexample}[]
% \pgfplotstabletypeset{pgfplotstable.example4.dat}
% \vrule
% 
% \pgfplotstabletypeset[
% 	columns/b/.style={fixed,precision=1},
% ]
% 	{pgfplotstable.example4.dat}
% \vrule
% 
% \pgfplotstabletypeset[
% 	columns/b/.style={fixed,precision=1,dec sep align},
% ]
% 	{pgfplotstable.example4.dat}
% \vrule
% 
% \pgfplotstabletypeset[
% 	columns/b/.style={fixed,precision=1,dec sep align,dec sep align/no unbounded},
% ]
% 	{pgfplotstable.example4.dat}
% \end{codeexample}
% \end{stylekey}
%-------------------------------------------------- 

\begin{stylekey}{/pgfplots/table/sci sep align=\marg{header column type} (initially c)}
	A style which aligns numerical columns at the exponent in scientific representation.

	The first argument determines the alignment of the header column. 

	It works similiarly to |dec sep align|, namely by introducing two artificial columns |r@{}l| for alignment.
	
	Please note that you need |\usepackage{array}| for this style.

	Please note that this style overwrites |column type|, |assign cell content| and some number formatting settings.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/dcolumn=\marg{tabular column type}\marg{type for column name} (initially \{D\{.\}\{.\}\{2\}\}\{c\})}
	A style which can be used together with the |dcolumn| package of David Carlisle. It also enables alignment at the decimal separator. However, the decimal separator needs to be exactly one character which is incompatible with `|{,}|' (the default setting for |use comma|).
\end{stylekey}

\begin{pgfplotskey}{table/sort=\marg{true,false} (initially false)}
	If set to |true|, |\pgfplotstabletypeset| will sort the table before applying its operation.

	See the description of |\pgfplotstablesort| for how to configure |sort key| and |sort cmp|.

\begin{codeexample}[]
\pgfplotstabletypeset[
	sort,sort key=error2,
	columns={dof,error1,error2},
	columns/error1/.style={sci,sci subscript,sci zerofill,dec sep align},
	columns/error2/.style={sci,sci subscript,sci zerofill,dec sep align},
]
	{pgfplotstable.example1.dat}
\end{codeexample}

	The |sort| mechanism is applied before the actual typesetting routine starts, i.e.\ it has the same effect as if you'd call |\pgfplotstablesort| manually before typesetting the table (however, the |sort| key has the advantage of respective the |include outfiles| caching mechanism). Any |create on use| specifications are resolved before calling the |sort key|.


	%The |sort| key applies also to |\addplot table[sort,read completely]|.
\end{pgfplotskey}

\begin{stylekey}{/pgfplots/table/every first column}
A style which is installed for every first column only.
\begin{codeexample}[narrow]
\pgfplotstabletypeset[
 every head row/.style={before row=\hline,after row=\hline\hline},
 every last row/.style={after row=\hline},
 every first column/.style={
  column type/.add={|}{}
 },
 every last column/.style={
  column type/.add={}{|}
 }]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every last column}
A style which is installed for every last column only.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every even column}
A style which is installed for every column with even column index (starting with~$0$).
{
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))},info},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}

\begin{codeexample}[code only]
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))},info},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{colortbl}
\pgfplotstabletypeset[
 every even column/.style={
  column type/.add={>{\columncolor[gray]{.8}}}{}
}]
	{pgfplotstable.example1.dat}
\end{codeexample}
}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every odd column}
A style which is installed for every column with odd column index (starting with~$0$).
\end{stylekey}

\begin{command}{\pgfplotstablecol}
	During the evaluation of row or column options, this command expands to the current columns' index.
\end{command}
\begin{command}{\pgfplotstablecolname}
	During the evaluation of column options, this command expands to the current column's name. It is valid while |\pgfplotstabletypeset| processes the column styles (including the preprocessing step explained in section~\ref{sec:pgfplotstable:preproc}), prepares the output cell content and checks row predicates.
\end{command}
\label{pgfplotstable:page:tablerow}
\begin{command}{\pgfplotstablerow}
	During the evaluation of row or column options, this command expands to the current rows' index.
\end{command}
\begin{command}{\pgfplotstablecols}
	During the evaluation of row or column options, this command expands to the total number of columns in the output table.
\end{command}
\begin{command}{\pgfplotstablerows}
	During evaluation of \emph{columns}, this command expands to the total number of \emph{input} rows. You can use it inside of |row predicate|.

	During evaluation of \emph{rows}, this command expands to the total number of \emph{output} rows.
\end{command}
\begin{command}{\pgfplotstablename}
	During |\pgfplotstabletypeset|, this macro contains the table's macro name as top-level expansion. If you are unfamiliar with ``top-level-expansions'' and `|\expandafter|', you will probably never need this macro.
	
	Advances users may benefit from expressions like 
	
	|\expandafter\pgfplotstabletypeset\pgfplotstablename|.

	For tables which have been loaded from disk (and have no explicitly assigned macro name), this expands to a temporary macro.
\end{command}


\subsection{Configuring Row Appearance: Styles}
The following styles allow to configure the final table code \emph{after any cell contents have been assigned}.

\begin{key}{/pgfplots/table/before row=\marg{\TeX\ code}}	
	Contains \TeX\ code which will be installed before the first cell in a row.
\end{key}

\begin{key}{/pgfplots/table/after row=\marg{\TeX\ code}}	
	Contains \TeX\ code which will be installed after the last cell in a row (i.e. after |\\|).
\end{key}

\begin{stylekey}{/pgfplots/table/every even row}
	A style which is installed for each row with even row index. The first row is supposed to be a ``head'' row and does not count. Indexing starts with~$0$.
{
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}

\begin{codeexample}[code only]
\pgfplotstableset{
	columns={dof,error1,{grad(log(dof),log(error2))}},
	columns/error1/.style={
		column name=$L_2$,
		sci,sci zerofill,sci subscript,
		precision=3},
	columns/dof/.style={
		int detect,
		column name=\textsc{Dof}},
	columns/{grad(log(dof),log(error2))}/.style={
		column name=slopes $L_2$,
		fixed,fixed zerofill,
		precision=1}}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
]
	{pgfplotstable.example1.dat}
\end{codeexample}

\begin{codeexample}[narrow,graphic=white]
% requires \usepackage{booktabs,colortbl}
\pgfplotstabletypeset[
	every even row/.style={
		before row={\rowcolor[gray]{0.9}}},
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
]
	{pgfplotstable.example1.dat}
\end{codeexample}

}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every odd row}	
	A style which is installed for each row with odd row index. The first row is supposed to be a ``head'' row and does not count. Indexing starts with~$0$.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every head row}	
	A style which is installed for each first row in the tabular. This can be used to adjust options for column names or to add extra lines/colours.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every first row}	
	A style which is installed for each first \emph{data} row, i.e. after the head row.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every last row}	
	A style which is installed for each last \emph{data} row.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/every row no \meta{index}}	
	A style which is installed for the row with index \meta{index}.
\end{stylekey}

\subsection{Customizing and Getting the Tabular Code}
The following keys allow changes of alignment (|begin table|) and |font| and they allow to write the generated code to |outfile|s (see also |write to macro|). Furthermore, the generated code can be fine--tuned to provide other sorts of table output, beyond \LaTeX.
\begin{stylekey}{/pgfplots/table/every table=\marg{file name}}
	A style which is installed at the beginning of every |\pgfplotstabletypeset| command\footnote{The \texttt{every table} style is installed \emph{after} options provided to \texttt{\textbackslash pgfplotstabletypeset}; it has higher precedence.}.

	The table file name is given as first argument.
\end{stylekey}

\begin{key}{/pgfplots/table/font=\marg{font name} (initially empty)}
	Assigns a font used for the complete table.
\end{key}

\begin{key}{/pgfplots/table/begin table=\marg{code} (initially \textbackslash begin\{tabular\})}
	Contains \marg{code} which is generated as table start.

	The following example uses a |longtable| instead\index{longtable} of |tabular|:
\begin{codeexample}[code only]
\pgfplotstableset{
	begin table=\begin{longtable},
	end table=\end{longtable},
}
\end{codeexample}

	It is also possible to \emph{change} the value. For example,
\begin{codeexample}[code only]
\pgfplotstableset{
	begin table/.add={}{[t]},
}
\end{codeexample}
	prepends the empty string |{}| and appends the prefix |[t]|. Thus, `|\begin{tabular}|' becomes `|\begin{tabular}[t]|'.
\end{key}
\begin{key}{/pgfplots/table/end table=\marg{code} (initially \textbackslash end\{tabular\})}
	Contains \marg{code} which is generated as table end.
\end{key}

\begin{codekey}{/pgfplots/table/typeset cell}
	A code key which assigns \declareandlabel{/pgfplots/table/@cell content} to the final output of the current cell.

	The first argument, |#1|, is the final cell's value. After this macro, the value of |@cell content| will be written to the output.

	The default implementation is
\begin{codeexample}[code only]
\ifnum\pgfplotstablecol=\pgfplotstablecols
	\pgfkeyssetvalue{/pgfplots/table/cell content}{#1\\}%
\else
	\pgfkeyssetvalue{/pgfplots/table/cell content}{#1&}%
\fi
\end{codeexample}
	\paragraph{Attention:} The value of |\pgfplotstablecol| starts with $1$ in this context, i.e.\ it is in the range $1,\dotsc,n$ where $n=$ |\pgfplotstablecols|. This simplifies checks whether we have the last column.
\end{codekey}

\begin{key}{/pgfplots/table/outfile=\marg{file name} (initially empty)}
\label{page:outfile}
	Writes the generated tabular code into \marg{file name}. It can then be used with |\input|\marg{file name}, \PGFPlotstable\ is no longer required since it contains a completely normal |tabular|.
	\pgfplotstableset{begin table=\begin{tabular}}
\begin{codeexample}[]
\pgfplotstabletypeset[
	columns={dof,error1},
	outfile=pgfplotstable.example1.out.tex]
	{pgfplotstable.example1.dat}
\end{codeexample}
and |pgfplotstable.example1.out.tex| contains
%\lstdefineformat{inp}{\\\\=\string\newline}%
\lstinputlisting[basicstyle=\ttfamily\footnotesize]{pgfplotstable.example1.out.tex}

The command |\pgfutilensuremath| checks whether math mode is active and switches to math mode if necessary\footnote{Please note that \lstinline{\\pgfutilensuremath} needs to be replaced by \lstinline{\\ensuremath} if you want to use the output file independent of \PGF. That can be done by \lstinline{\\let\\pgfutilensuremath=\\ensuremath} which enables the \LaTeX-command \lstinline{\\ensuremath}.}.
\end{key}

\begin{key}{/pgfplots/table/include outfiles=\marg{boolean} (initially false)}
	If enabled, any already existing outfile will be |\input| instead of overwritten.
\begin{codeexample}[code only]
\pgfplotstableset{include outfiles} % for example in the document's preamble
\end{codeexample}
	This allows to place any corrections manually into generated output files since \PGFPlotstable\ won't overwrite the resulting tables automatically.

	This will affect tables for which the |outfile| option is set. If you wish to apply it to every table, consider
\begin{codeexample}[code only]
\pgfplotstableset{every table/.append style={outfile={#1.out}}}
\end{codeexample}
	\noindent which will generate an |outfile| name for every table.
\end{key}
\begin{key}{/pgfplots/table/force remake=\marg{boolean} (initially false)}
	If enabled, the effect of |include outfiles| is disabled. As all key settings only last until the next brace (or |\end|\meta{}), this key can be used to re-generate some output files while others are still included.
\end{key}

\begin{key}{/pgfplots/table/write to macro=\marg{\textbackslash macroname}}
	If the value of |write to macro| is not empty, the completely generated (tabular) code will be written into the macro \marg{\textbackslash macroname}.

	See the |typeset=false| key in case you need \emph{only} the resulting macro.
\end{key}

\begin{key}{/pgfplots/table/skip coltypes=\mchoice{true,false} (initially false)}
	Allows to skip the \marg{coltypes} in |\begin{tabular}|\marg{coltypes}. This allows simplifications for other table types which don't have \LaTeX's table format.
\end{key}

\begin{key}{/pgfplots/table/typeset=\mchoice{true,false} (initially true)}
	A boolean which disables the final typesetting stage. Use |typeset=false| in conjunction with |write to macro| if only the generated code is of interest and \TeX\ should not attempt to produce any content in the output |pdf|.	
\end{key}

\begin{key}{/pgfplots/table/debug=\marg{boolean} (initially false)}
	If enabled, will write every final tabular code to your log file.
\end{key}

\begin{key}{/pgfplots/table/TeX comment=\marg{comment sign} (initially \%)}
	The comment sign which is inserted into outfiles to suppress trailing white spaces.
\end{key}

\noindent As last example, we use \PGFPlotstable\ to write an |.html| file (including number formatting and rounding!):
% \usepackage{listings}
\begin{codeexample}[width=8cm]
\pgfplotstabletypeset[
	begin table={<table>}, end table={</table>},
	typeset cell/.style={
	  /pgfplots/table/@cell content={<td>#1</td>}
	},
	before row=<tr>,after row=</tr>,
	skip coltypes, typeset=false, 
	verbatim,% configures number printer
	TeX comment=,
	columns={level,dof,error1},
	outfile=pgfplotstable.example1.out.html,
]{pgfplotstable.example1.dat}
\lstinputlisting
	[basicstyle=\ttfamily\footnotesize]
	{pgfplotstable.example1.out.html}
\end{codeexample}

\subsection{Defining Column Types for \texttt{tabular}}
Besides input of text files, it is sometimes desireable to define column types for existing \texttt{tabular} environments.

\begin{command}{\newcolumntype\marg{letter}\oarg{number of arguments}$>$\marg{before column}\meta{column type}$<$\marg{after column}}
The command |\newcolumntype| is part of the |array| package and it defines a new column type \marg{letter} for use in \LaTeX\ tabular environments.
\begin{codeexample}[code only]
\usepackage{array}
\end{codeexample}

\begin{codeexample}[]
\newcolumntype{d}{>{-}c<{+}}
\begin{tabular}{dl}
a & b \\
c & d \\
\end{tabular}
\end{codeexample}

Now, the environment |pgfplotstablecoltype| can be used in \marg{before column} and \marg{after column} to define numerical columns:
% \usepackage{array}
\begin{codeexample}[]
% requires \usepackage{array}
\newcolumntype{L}[1]
	{>{\begin{pgfplotstablecoltype}[#1]}r<{\end{pgfplotstablecoltype}}}

\begin{tabular}{L{int detect}L{sci,sci subscript,sci zerofill}}
9      & 2.50000000e-01\\
25     & 6.25000000e-02\\
81     & 1.56250000e-02\\
289    & 3.90625000e-03\\
1089   & 9.76562500e-04\\
4225   & 2.44140625e-04\\
16641  & 6.10351562e-05\\
66049  & 1.52587891e-05\\
263169 & 3.81469727e-06\\
1050625& 9.53674316e-07\\
\end{tabular}
\end{codeexample}
\noindent The environment |pgfplotstablecoltype| accepts an optional argument which may contain any number formatting options. It is an error if numerical columns contain non-numerical data, so it may be necessary to use |\multicolumn| for column names.

\begin{codeexample}[]
% requires \usepackage{array}
\newcolumntype{L}[1]
	{>{\begin{pgfplotstablecoltype}[#1]}r<{\end{pgfplotstablecoltype}}}

\begin{tabular}{L{int detect}L{sci,sci subscript,sci zerofill}}
\multicolumn{1}{r}{Dof} & \multicolumn{1}{r}{Error}\\
9      & 2.50000000e-01\\
25     & 6.25000000e-02\\
81     & 1.56250000e-02\\
289    & 3.90625000e-03\\
1089   & 9.76562500e-04\\
4225   & 2.44140625e-04\\
16641  & 6.10351562e-05\\
66049  & 1.52587891e-05\\
263169 & 3.81469727e-06\\
1050625& 9.53674316e-07\\
\end{tabular}
\end{codeexample}
\end{command}

\subsection{Number Formatting Options}
\label{sec:number:printing}%
The following extract of \cite{tikz} explains how to configure number formats. The common option prefix |/pgf/number format| can be omitted; it will be recognised automatically.
\begin{command}{\pgfmathprintnumber\marg{x}}
Generates pretty-printed output for the (real) number \marg{x}. The input number \marg{x} is parsed using |\pgfmathfloatparsenumber| which allows arbitrary precision.

Numbers are typeset in math mode using the current set of number printing options, see below. Optional arguments can also be provided using |\pgfmathprintnumber[|\meta{options}|]|\marg{x}.
\end{command}

\begin{command}{\pgfmathprintnumberto\marg{x}\marg{\textbackslash macro}}
	Returns the resulting number into \marg{\textbackslash macro} instead of typesetting it directly.	
\end{command}

\begin{key}{/pgf/number format/fixed}
Configures |\pgfmathprintnumber| to round the number to a fixed number of digits after the period, discarding any trailing zeros.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the appearance.
\end{key}

\begin{key}{/pgf/number format/fixed zerofill=\marg{boolean}  (default true)}
Enables or disables zero filling for any number drawn in fixed point format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,fixed zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
This key affects numbers drawn with |fixed| or |std| styles (the latter only if no scientific format is choosen).
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,std,fixed zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-05}\hspace{1em}
\pgfmathprintnumber{1}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the appearance.
\end{key}

\begin{key}{/pgf/number format/sci}
Configures |\pgfmathprintnumber| to display numbers in scientific format, that means sign, mantisse and exponent (basis~$10$). The mantisse is rounded to the desired |precision| (or |sci precision|, see below).

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}

See section~\ref{sec:number:styles} for how to change the exponential display style.
\end{key}

\begin{key}{/pgf/number format/sci zerofill=\marg{boolean}  (default true)}
Enables or disables zero filling for any number drawn in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci zerofill,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
As with |fixed zerofill|, this option does only affect numbers drawn in |sci| format (or |std| if the scientific format is chosen).

See section~\ref{sec:number:styles} for how to change the exponential display style.
\end{key}

\begin{stylekey}{/pgf/number format/zerofill=\marg{boolean} (default true)}
	Sets both, |fixed zerofill| and |sci zerofill| at once.
\end{stylekey}

\begin{keylist}{/pgf/number format/std,%
	/pgf/number format/std=\meta{lower e},
	/pgf/number format/std=\meta{lower e}:\meta{upper e}}
Configures |\pgfmathprintnumber| to a standard algorithm. It chooses either |fixed| or |sci|, depending on the order of magnitude. Let $n=s \cdot m \cdot 10^e$ be the input number and $p$ the current precision. If $-p/2 \le e \le 4$, the number is displayed using |fixed| format. Otherwise, it is displayed using |sci| format. 

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,std,precision=2}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
The parameters can be customized using the optional integer argument(s): if $\text{\meta{lower e}} \le e \le \text{\meta{upper e}}$, the number is displayed in |fixed| format, otherwise in |sci| format. Note that \meta{lower e} should be negative for useful results. The precision used for scientific format can be adjusted with |sci precision| if necessary.

\end{keylist}

\begin{key}{/pgf/number format/int detect}
Configures |\pgfmathprintnumber| to detect integers automatically. If the input number is an integer, no period is displayed at all. If not, the scientific format is chosen.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,int detect,precision=2}
\pgfmathprintnumber{15}\hspace{1em}
\pgfmathprintnumber{20}\hspace{1em}
\pgfmathprintnumber{20.4}\hspace{1em}
\pgfmathprintnumber{0.01}\hspace{1em}
\pgfmathprintnumber{0}
\end{codeexample}
\end{key}

\begin{command}{\pgfmathifisint\marg{number constant}\marg{true code}\marg{false code}}
	A command which does the same check as |int detect|, but it invokes \meta{true code} if the \meta{number constant} actually is an integer and the \meta{false code} if not.

	As a side--effect, |\pgfretval| will contain the parsed number, either in integer format or as parsed floating point number.

	The argument \meta{number constant} will be parsed with |\pgfmathfloatparsenumber|. 
\begin{codeexample}[]
15 \pgfmathifisint{15}{is an int: \pgfretval.}{is no int}\hspace{1em}
15.5 \pgfmathifisint{15.5}{is an int: \pgfretval.}{is no int}
\end{codeexample}
\end{command}

\begin{key}{/pgf/number format/int trunc}
Truncates every number to integers (discards any digit after the period).

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,int trunc}
\pgfmathprintnumber{4.568}\hspace{1em}
\pgfmathprintnumber{5e-04}\hspace{1em}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{24415.98123}\hspace{1em}
\pgfmathprintnumber{123456.12345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/frac}
Displays numbers as fractionals.

\begin{codeexample}[width=3cm]
\pgfkeys{/pgf/number format/frac}
\pgfmathprintnumber{0.333333333333333}\hspace{1em}
\pgfmathprintnumber{0.5}\hspace{1em}
\pgfmathprintnumber{2.133333333333325e-01}\hspace{1em}
\pgfmathprintnumber{0.12}\hspace{1em}
\pgfmathprintnumber{2.666666666666646e-02}\hspace{1em}
\pgfmathprintnumber{-1.333333333333334e-02}\hspace{1em}
\pgfmathprintnumber{7.200000000000000e-01}\hspace{1em}
\pgfmathprintnumber{6.666666666666667e-02}\hspace{1em}
\pgfmathprintnumber{1.333333333333333e-01}\hspace{1em}
\pgfmathprintnumber{-1.333333333333333e-02}\hspace{1em}
\pgfmathprintnumber{3.3333333}\hspace{1em}
\pgfmathprintnumber{1.2345}\hspace{1em}
\pgfmathprintnumber{1}\hspace{1em}
\pgfmathprintnumber{-6}
\end{codeexample}

\begin{key}{/pgf/number format/frac TeX=\marg{\textbackslash macro} (initially \texttt{\textbackslash frac})}
	Allows to use a different implementation for |\frac| inside of the |frac| display type.
\end{key}
\begin{key}{/pgf/number format/frac denom=\meta{int} (initially empty)}
	Allows to provide a custom denominator for |frac|.
\begin{codeexample}[width=3cm]
\pgfkeys{/pgf/number format/.cd,frac, frac denom=10}
\pgfmathprintnumber{0.1}\hspace{1em}
\pgfmathprintnumber{0.5}\hspace{1em}
\pgfmathprintnumber{1.2}\hspace{1em}
\pgfmathprintnumber{-0.6}\hspace{1em}
\pgfmathprintnumber{-1.4}\hspace{1em}
\end{codeexample}
\end{key}
\begin{key}{/pgf/number format/frac whole=\mchoice{true,false} (initially true)}
	Configures whether complete integer parts shall be placed in front of the fractional part. In this case, the fractional part will be less then $1$. Use |frac whole=false| to avoid whole number parts.
\begin{codeexample}[width=3cm]
\pgfkeys{/pgf/number format/.cd,frac, frac whole=false}
\pgfmathprintnumber{20.1}\hspace{1em}
\pgfmathprintnumber{5.5}\hspace{1em}
\pgfmathprintnumber{1.2}\hspace{1em}
\pgfmathprintnumber{-5.6}\hspace{1em}
\pgfmathprintnumber{-1.4}\hspace{1em}
\end{codeexample}
\end{key}
\begin{key}{/pgf/number format/frac shift=\marg{integer} (initially 4)}
	In case you experience problems because of stability problems, try experimenting with a different |frac shift|. 
	Higher shift values $k$ yield higher sensitivity to inaccurate data or inaccurate arithmetics.

	Technically, the following happens. If $r < 1$ is the fractional part of the mantissa, then a scale $i = 1/r \cdot 10^k$ is computed where $k$ is the shift; fractional parts of $i$ are neglected. The value $1/r$ is computed internally, its error is amplified.

	If you still experience stability problems, use |\usepackage{fp}| in your preamble. The |frac| style will then automatically employ the higher absolute precision of |fp| for the computation of $1/r$.
\end{key}
\end{key}

\begin{key}{/pgf/number format/precision=\marg{number}}
Sets the desired rounding precision for any display operation. For scientific format, this affects the mantisse.
\end{key}
\begin{key}{/pgf/number format/sci precision=\meta{number or empty} (initially empty)}
	Sets the desired rounding precision only for |sci| styles. 

	Use |sci precision={}| to restore the initial configuration (which uses the argument provided to |precision| for all number styles).
\end{key}


\subsubsection{Changing Number Format Display Styles}%
\label{sec:number:styles}%
You can change the way how numbers are displayed. For example, if you use the `\texttt{fixed}' style, the input number is rounded to the desired precision and the current fixed point display style is used to typeset the number. The same is applied to any other format: first, rounding routines are used to get the correct digits, afterwards a display style generates proper \TeX-code.

\begin{key}{/pgf/number format/set decimal separator=\marg{text}}
Assigns \marg{text} as decimal separator for any fixed point numbers (including the mantisse in sci format).
\end{key}
\begin{key}{/pgf/number format/dec sep=\marg{text}}
	Just another name for |set decimal separator|.
\end{key}


\begin{key}{/pgf/number format/set thousands separator=\marg{text}}
Assigns \marg{text} as thousands separator for any fixed point numbers (including the mantisse in sci format).

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={}}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={}}
\pgfmathprintnumber{1234567890}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={.}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={,}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,
	precision=2,
	set thousands separator={{{{,}}}}}
\pgfmathprintnumber{1234567890}
\end{codeexample}
The last example employs commas and disables the default comma-spacing. 
\end{key}
\begin{key}{/pgf/number format/1000 sep=\marg{text}}
	Just another name for |set thousands separator|.
\end{key}

\begin{key}{/pgf/number format/min exponent for 1000 sep=\marg{number} (initially 0)}
	Defines the smalles exponent in scientific notation which is required to draw thousand separators. The exponent is the number of digits minus one, so $\meta{number}=4$ will use thousand separators starting with $1e4 = 10000$.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=0}
\pgfmathprintnumber{5000}; \pgfmathprintnumber{1000000}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=4}
\pgfmathprintnumber{1000}; \pgfmathprintnumber{5000}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	int detect,
	1000 sep={\,},
	min exponent for 1000 sep=4}
\pgfmathprintnumber{10000}; \pgfmathprintnumber{1000000}
\end{codeexample}
\noindent A value of |0| disables this feature (negative values are ignored).
\end{key}


\begin{key}{/pgf/number format/use period}
A predefined style which installs periods `\texttt{.}' as decimal separators and commas `\texttt{,}' as thousands separators. This style is the default.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use period}
\pgfmathprintnumber{12.3456}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use period}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/use comma}
A predefined style which installs commas `\texttt{,}' as decimal separators and periods `\texttt{.}' as thousands separators.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use comma}
\pgfmathprintnumber{12.3456}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,fixed,precision=2,use comma}
\pgfmathprintnumber{1234.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/skip 0.=\marg{boolean} (initially false)}
	Configures whether numbers like $0.1$ shall be typeset as $.1$ or not.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,precision=2,
	skip 0.}
\pgfmathprintnumber{0.56}
\end{codeexample}
\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,
	fixed,
	fixed zerofill,precision=2,
	skip 0.=false}
\pgfmathprintnumber{0.56}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/showpos=\marg{boolean} (initially false)}
	Enables or disables display of plus signs for non-negative numbers.
\begin{codeexample}[]
\pgfkeys{/pgf/number format/showpos}
\pgfmathprintnumber{12.345}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/showpos=false}
\pgfmathprintnumber{12.345}
\end{codeexample}

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,showpos,sci}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{stylekey}{/pgf/number format/print sign=\marg{boolean}}
	A style which is simply an alias for |showpos=|\marg{boolean}.
\end{stylekey}

\begin{key}{/pgf/number format/sci 10e}
Uses $m \cdot 10^e$ for any number displayed in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci 10e}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci 10\textasciicircum e}
The same as `|sci 10e|'.
\end{key}

\begin{key}{/pgf/number format/sci e}
Uses the `$1e{+}0$' format which is generated by common scientific tools for any number displayed in scientific format.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci e}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci E}
The same with an uppercase `\texttt{E}'.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci E}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci subscript}
Typesets the exponent as subscript for any number displayed in scientific format. This style requires very few space.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci subscript}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci superscript}
Typesets the exponent as superscript for any number displayed in scientific format. This style requires very few space.

\begin{codeexample}[]
\pgfkeys{/pgf/number format/.cd,sci,sci superscript}
\pgfmathprintnumber{12.345}
\end{codeexample}
\end{key}

\begin{key}{/pgf/number format/sci generic=\marg{keys}}
Allows to define an own number style for the scientific format. Here, \meta{keys} can be one of the following choices (omit the long key prefix):

\begin{key}{/pgf/number format/sci generic/mantisse sep=\marg{text} (initially empty)}
	Provides the separator between a mantisse and the exponent. It might be |\cdot|, for example,
\end{key}
\begin{key}{/pgf/number format/sci generic/exponent=\marg{text} (initially empty)}
	Provides text to format the exponent. The actual exponent is available as argument |#1| (see below).
\end{key}

\begin{codeexample}[]
\pgfkeys{
	/pgf/number format/.cd,
	sci,
	sci generic={mantisse sep=\times,exponent={10^{#1}}}}
\pgfmathprintnumber{12.345};
\pgfmathprintnumber{0.00012345}
\end{codeexample}
	The \meta{keys} can depend on three parameters, namely on |#1| which is the exponent, |#2| containing the flags entity of the floating point number and |#3| is the (unprocessed and unformatted) mantisse.

	Note that |sci generic| is \emph{not} suitable to modify the appearance of fixed point numbers, nor can it be used to format the mantisse (which is typeset like fixed point numbers). Use |dec sep|, |1000 sep| and |print sign| to customize the mantisse.
\end{key}

\begin{key}{/pgf/number format/@dec sep mark=\marg{text}}
	Will be placed right before the place where a decimal separator belongs to. However, \marg{text} will be inserted even if there is no decimal separator. It is intented as place-holder for auxiliary routines to find alignment positions.

	This key should never be used to change the decimal separator! Use |dec sep| instead. 
\end{key}

\begin{key}{/pgf/number format/@sci exponent mark=\marg{text}}
	Will be placed right before exponents in scientific notation. It is intented as place-holder for auxiliary routines to find alignment positions.

	This key should never be used to change the exponent!
\end{key}

\begin{key}{/pgf/number format/assume math mode=\marg{boolean} (default true)}
	Set this to |true| if you don't want any checks for math mode.
	
	The initial setting installs a |\pgfutilensuremath| around each final number to change to math mode if necessary. Use |assume math mode=true| if you know that math mode is active and you don't want |\pgfutilensuremath|.
\end{key}

\begin{stylekey}{/pgf/number format/verbatim}
	A style which configures the number printer to produce verbatim text output, i.e.\ it doesn't contain \TeX\ macros.
\begin{codeexample}[]
\pgfkeys{
	/pgf/fpu,
	/pgf/number format/.cd,
	sci,
	verbatim}
\pgfmathprintnumber{12.345};
\pgfmathprintnumber{0.00012345};
\pgfmathparse{exp(15)}
\pgfmathprintnumber{\pgfmathresult}
\end{codeexample}
	The style resets |1000 sep|, |dec sep|, |print sign|, |skip 0.| and sets |assume math mode|. Furthermore, it installs a |sci generic| format for verbatim output of scientific numbers.

	However, it will still respect |precision|, |fixed zerofill|, |sci zerofill| and the overall styles |fixed|, |sci|, |int detect| (and their variants). It might be useful if you intent to write output files.
\end{stylekey}




\section{From Input Data To Output Tables: Data Processing}
The conversion from an unprocessed input table to a final typesetted |tabular| code uses four stages for every cell,
\begin{enumerate}
	\item Loading the table,
	\item Preprocessing,
	\item Typesetting,
	\item Postprocessing.
\end{enumerate}
The main idea is to select one typesetting algorithm (for example ``format my numbers with the configured number style''). This algorithm usually doesn't need to be changed. Fine tuning can then be done using zero, one or more preprocessors and postprocessors. Preprocessing can mean to select only particular rows or to apply some sort of operation before the typesetting algorithm sees the content. Postprocessing means to apply fine-tuning to the resulting \TeX\ output -- for example to deal with empty cells or to insert unit suffixes or modify fonts for single cells.

\subsection{Loading the table}
This first step to typeset a table involves the obvious input operations. Furthermore, the ``new column creation'' operations explained in section~\ref{pgfplotstable:createcol} are processed at this time. The table data is read (or acquired) as already explained earlier in this manual. Then, if columns are missing, column alias and |create on use| specifications will be processed as part of the loading procedure. See section~\ref{pgfplotstable:createcol} for details about column creation.

\subsection{Typesetting Cell Content}
Typesetting cells means to take their value and ``do something''. In many cases, this involves number formatting routines. For example, the ``raw'' input data |12.56| might become |1.26| |\cdot| |10^1|. The result of this stage is no longer useful for content-based computations. The typesetting step follows the preprocessing step.

\begin{codekey}{/pgfplots/table/assign cell content}
	Allows to redefine the algorithm which assigns cell contents. The argument |#1| is the (unformatted) contents of the input table. 
	
	The resulting output needs to be written to |/pgfplots/table/@cell content|.
% \usepackage{booktabs}
% \usepackage{multirow}
\begin{codeexample}[]
% An example how to use 
% \usepackage{multirow} and
% \usepackage{booktabs}:
\pgfplotstabletypeset[
	columns/Z/.style={
		column name={},
		assign cell content/.code={% use \multirow for Z column:
			\ifnum\pgfplotstablerow=0
				\pgfkeyssetvalue{/pgfplots/table/@cell content}
					{\multirow{4}{*}{##1}}%
			\else
				\pgfkeyssetvalue{/pgfplots/table/@cell content}{}%
			\fi
		},
	},
	% use \booktabs as well (compare examples above):
	every head row/.style={before row=\toprule,after row=\midrule},
	every last row/.style={after row=\bottomrule},
	row sep=\\,col sep=&,
]{% here: inline data in tabular format:
	Z    & a & b \\
	data & 1 & 2 \\
	     & 3 & 4 \\
	     & 5 & 6 \\
	     & 7 & 8 \\
}
\end{codeexample}
\index{multirow}%
\noindent The example above uses |\usepackage{multirow}| to format column |Z|. More precisely, it uses |\multirow{4}{*}{data}| for row \#0 of column |Z| and the empty string for any other row in column |Z|.

	Please note that you may need special attention for |#1=|\marg{}, i.e. the empty string. This may happen if a column has less rows than the first column. \PGFPlotstable\ will balance columns automatically in this case, inserting enough empty cells to match the number of rows of the first column.

	Please note further that if any column has more entries than the first column, these entries will be skipped and a warning message will be issued into the log file.

	This key is evaluated inside of a local \TeX\ group, so any local macro assignments will be cleared afterwards.
\end{codekey}

\begin{stylekey}{/pgfplots/table/numeric type}
	A style which (re)-defines |assign cell content| back to its original value which assumes numerical data.

	It invokes |\pgfmathprintnumberto| and writes the result into |@cell content|.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/string type}
	A style which redefines |assign cell content| to simply return the ``raw'' input data, that means as text column. This assumes input tables with valid \LaTeX\ content (verbatim printing is not supported).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/verb string type}
	A style which redefines |assign cell content| to return the ``raw'' as--is. Thus, it is quite similar to |string type| -- but it will return control sequences and (many, not all) special characters without expanding them.

	You may need to combine |verb string type| with |special chars|.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/numeric as string type}
	A style which redefines |assign cell content| such that it assumes numerical input data. It returns a string literal describing the input number either as integer or in scientific (exponential) notation. In contrast to |numeric type|, it does not apply number formatting.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/date type=\marg{date format}}% (initially \year-\month-\day)}
	A style which expects ISO dates of the form |YYYY-MM-DD| in each cell and produces pretty-printed strings on output. The output format is given as \marg{date format}. Inside of \marg{date format}, several macros which are explained below can be used.
% \usepackage{pgfcalendar}
\begin{codeexample}[]
% Requires 
% \usepackage{pgfcalendar}
\pgfplotstableset{columns={date,account1}}

% plotdata/accounts.dat contains:
%
% date              account1  account2  account3
% 2008-01-03        60        1200      400
% 2008-02-06        120       1600      410
% 2008-03-15        -10       1600      410
% 2008-04-01        1800      500       410
% 2008-05-20        2300      500       410
% 2008-06-15        800       1920      410

% Show the contents in `string type':
\pgfplotstabletypeset[
	columns/date/.style={string type}
]{plotdata/accounts.dat}
\hspace{1cm}
% Show the contents in `date type':
\pgfplotstabletypeset[
	columns/date/.style={date type={\monthname\ \year}}
]{plotdata/accounts.dat}
\end{codeexample}
	This style \textbf{requires} to load the \PGF\  \textbf{calendar package}:
\begin{codeexample}[code only]
\usepackage{pgfcalendar}
\end{codeexample}

\begin{command}{\year}
	Inside of \marg{date format}, this macro expands to the year as number (like |2008|).
\end{command}
\begin{command}{\month}
	Inside of \marg{date format}, this macro expands to the month as number, starting with~$1$ (like |1|).
\end{command}
\begin{command}{\monthname}
	Inside of \marg{date format}, this macro expands to the month's name as set in the current language (like |January|).
	 See below for how to change the language.
\end{command}
\begin{command}{\monthshortname}
	Inside of \marg{date format}, this macro expands to the month's short name as set in the current language (like |Jan|). 
	See below for how to change the language.
\end{command}
\begin{command}{\day}
	Inside of \marg{date format}, this macro expands to the day as number (like |31|).
\end{command}
\begin{command}{\weekday}
	Inside of \marg{date format}, this macro expands to the weekday number ($0$ for Monday, $1$ for Tuesday etc.).
\end{command}
\begin{command}{\weekdayname}
	Inside of \marg{date format}, this macro expands to the weekday's name in the current language (like |Wednesday|).
	 See below for how to change the language.
\end{command}
\begin{command}{\weekdayshortname}
	Inside of \marg{date format}, this macro expands to the weekday's short name in the current language (like |Wed|).
	 See below for how to change the language.
\end{command}

\subsubsection*{Changing the language for dates}
The date feature is implemented using the \PGF\ calendar module. This module employs the package |translator| (if it is loaded). I don't have more detail yet, sorry. Please refer to \cite{tikz} for more details.
\end{stylekey}

\subsection{Preprocessing Cell Content}
\label{sec:pgfplotstable:preproc}
The preprocessing step allows to change cell contents \emph{before} any typesetting routine (like number formatting) has been applied. Thus, if tables contain numerical data, it is possible to apply math operations at this stage. Furthermore, cells can be erased depending on their numerical value. The preprocess step follows the data acquisition step (``loading step''). This means in particular that you can create (or copy) columns and apply operations on them.

\begin{codekey}{/pgfplots/table/preproc cell content}
	Allows to \emph{modify} the contents of cells \emph{before} |assign cell content| is called.

	The semantics is as follows: before the preprocessor, |@cell content| contains the raw input data (or, maybe, the result of another preprocessor call). After the preprocessor, |@cell content| is filled with a -- possibly modified -- value. The resulting value is then used as input to |assign cell content|.

	In the default settings, |assign cell content| expects numerical input. So, the preprocessor is expected to produce numerical output.

	It is possible to provide multiple preprocessor directives using |/.append code| or |/.append style| key handlers.

	In case you don't want (or need) stackable preprocessors, you can also use `|#1|' to get the raw input datum as it is found in the file. Furthermore, the key |@unprocessed cell content| will also contain the raw input datum.
\end{codekey}

\begin{stylekey}{/pgfplots/table/string replace=\marg{pattern}\marg{replacement}}
	Appends code to the current |preproc cell content| value which replaces every occurence of \marg{pattern} with \marg{replacement}. No expansion is performed during this step; \marg{pattern} must match literally.
\begin{codeexample}[]
\pgfplotstabletypeset[columns={level,dof}]
	{pgfplotstable.example1.dat}


\pgfplotstabletypeset[
	columns={level,dof},
	columns/level/.style={string replace={A}{B}}, % does nothing because there is no 'A'
	columns/dof/.style={string replace={256}{-42}}]  % replace '256' with '-42'
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/clear infinite}
	Appends code to the current |preproc cell content| value which replaces every infinite number with the empty string. This clears any cells with $\pm \infty$ and NaN.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/preproc/expr=\marg{math expression}}
	Appends code to the current |preproc cell content| value which evaluates \marg{math expression} for every cell. Arithmetics are carried out in floating point.	

	Inside of \marg{math expression}, use one of the following expressions to get the current cell's value.
	\begin{itemize}
		\item The string `|##1|' expands to the cell's content as it has been found in the input file, ignoring preceeding preprocessors.

		This is usually enough.

		\item The command |\thisrow|\marg{the currently processed column name} expands to the current cell's content. This will also include the results of preceeding preprocessors.

		Note that |\thisrow{}| in this context (inside of the preprocessor) is not as powerful as in the context of column creation routines: the argument must match exactly the name of the currently processed column name. You can also use the shorthand
		
		|\thisrow{\pgfplotstablecolname}|.

		\item The command |\pgfkeysvalueof{/pgfplots/table/@cell content}| is the same.
	\end{itemize}

\begin{codeexample}[]
\pgfplotstabletypeset[
	columns={level},
	columns/level/.style={
		column name={$2\cdot \text{level}+4$},
		preproc/expr={2*##1 + 4}
	}
]
	{pgfplotstable.example1.dat}
\end{codeexample}

	Empty cells won't be processed, assuming that a math expression with an ``empty number'' will fail. 
	
	Note that there is also an |create col/expr| which is more powerful than |preproc/expr|.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/multiply with=\marg{real number}}
	Appends code to the current |preproc cell content| value which multiplies every cell with \marg{real number}. Arithmetics are carried out in floating point.	
\end{stylekey}

\begin{stylekey}{/pgfplots/table/divide by=\marg{real number}}
	Appends code to the current |preproc cell content| value which divides every cell by \marg{real number}. Arithmetics are carried out in floating point.	
\end{stylekey}

\begin{stylekey}{/pgfplots/table/sqrt}
	Appends code to the current |preproc cell content| value which applies $\sqrt{x}$ to every non-empty cell. Arithmetics are carried out in floating point.	

	The following example copies the column |error1| and applies |sqrt| to the copy.
\begin{codeexample}[]
\pgfplotstableset{
	columns={error1,sqrterror1},
	create on use/sqrterror1/.style={create col/copy=error1},
	columns/error1/.style={column name=$\epsilon$},
	columns/sqrterror1/.style={sqrt,column name=$\sqrt \epsilon$},
	sci,sci 10e,precision=3,sci zerofill
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	Please take a look at section~\ref{pgfplotstable:createcol} for details about |create on use|.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/multiply -1}
	Appends code to current |preproc cell content| value which multiplies every cell with $-1$. This style does the same job as |multiply with=-1|, it is just faster because only the sign changes.
\begin{codeexample}[]
\pgfplotstableset{
	columns={dof,error2,slopes2},
	columns/error2/.style={sci,sci zerofill},
	columns/slopes2/.style={dec sep align,empty cells with={\ensuremath{-}}},
	create on use/slopes2/.style=
		{create col/gradient loglog={dof}{error2}}}

\pgfplotstabletypeset{pgfplotstable.example1.dat}

\pgfplotstabletypeset[columns/slopes2/.append style={multiply -1}]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{codekey}{/pgfplots/table/row predicate}
	A boolean predicate which allows to select particular rows of the input table, based on the current row's index. The argument |#1| contains the current row's index (starting with~$0$, not counting comment lines or column names).

	The return value is assigned to the \TeX-if \declareandlabel{\ifpgfplotstableuserow}. If the boolean is not changed, the return value is true.
\begin{codeexample}[narrow]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
	row predicate/.code={%
		\ifnum#1>4\relax
			\ifnum#1<8\relax
				\pgfplotstableuserowfalse
			\fi
		\fi}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
	Please note that |row predicate| is applied \emph{before} any other option which affects row (or column) appearance. It is evaluated before |assign cell content|. One of the consequences ist that even/odd row styles refer to those rows for which the predicate returns |true|. In fact, you can use |row predicate| to truncate the complete table before it has actually been processed. 
	
	During |row predicate|, the macro |\pgfplotstablerows| contains the total number of \emph{input} rows.
	
	Furthermore, |row predicate| applies only to the typeset routines, not the read methods. If you want to plot only selected table entries with |\addplot table|, use the \PGFPlots\ coordinate filter options.
\end{codekey}

\begin{stylekey}{/pgfplots/table/skip rows between index=\marg{begin}\marg{end}}
	A style which appends an |row predicate| which discards selected rows. The selection is done by index where indexing starts with~$0$. Every row with index $\meta{begin} \le i < \meta{end}$ will be skipped.
\begin{codeexample}[narrow]
% requires \usepackage{booktabs}
\pgfplotstabletypeset[
	every head row/.style={
		before row=\toprule,after row=\midrule},
	every last row/.style={
		after row=\bottomrule},
	skip rows between index={2}{4},
	skip rows between index={7}{9}
]
	{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/select equal part entry of=\marg{part no}\marg{part count}}
	A style which overwrites |row predicate| with a subset selection predicate. The idea is to split the current column into \marg{part count} equally sized parts and select only \marg{part no}.

	This can be used to simulate multicolumn tables.
\begin{codeexample}[]
% requires \usepackage{booktabs}
\pgfplotstableset{
	every head row/.style={before row=\toprule,after row=\midrule},
	every last row/.style={after row=\bottomrule}}

\pgfplotstabletypeset[string type]{pgfplotstable.example2.dat}%
~
\pgfplotstabletypeset[
	columns={A,B,A,B},
	display columns/0/.style={select equal part entry of={0}{2},string type},% first part of `A'
	display columns/1/.style={select equal part entry of={0}{2},string type},% first part of `B'
	display columns/2/.style={select equal part entry of={1}{2},string type},% second part of `A'
	display columns/3/.style={select equal part entry of={1}{2},string type},% second part of `B'
]
	{pgfplotstable.example2.dat}
\end{codeexample}
	The example above shows the original file as-is on the left side. The right side shows columns A,B,A,B~-- but only half of the elements are shown, selected by indices \#0 or \#1 of \#2. The parts are equally large, up to a remainder. 
	
	If the available number of rows is not dividable by \marg{part count}, the remaining entries are distributed equally among the first parts.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/unique=\marg{column name}}
	A style which appends a |row predicate| which suppresses successive occurances of the same elements in \marg{column name}.
	For example, if \marg{column name} contains |1,1,3,5,5,6,5,0|, the application of |unique| results in |1,3,5,6,5,0| (the last |5| is kept -- it is not directly preceeded by another |5|).

	The algorithm uses string token comparison to find multiple occurances\footnote{To be more precise, the comparison is done using \texttt{\textbackslash ifx}, i.e. cell contents won't be expanded. Only the tokens as they are seen in the input table will be used.}.

	The argument \marg{column name} can be a column name, index, alias, or |create on use| specification (the latter one must not depend on other |create on use| statements). It is not necessary to provide a \marg{column name} which is part of the output.

	However, it \emph{is} necessary that the |unique| predicate can be evaluated for all columns, starting with the first one. That means it is an error to provide |unique| somewhere deep in column--specific styles.
\end{stylekey}

\subsection{Postprocessing Cell Content}
The postprocessing step is applied after the typesetting stage, that means it can't access the original input data. However, it can apply final formatting instructions which are not content based.

\begin{codekey}{/pgfplots/table/postproc cell content}
	Allows to \emph{modify} assigned cell content \emph{after} it has been assigned, possibly content-dependent. Ideas could be to draw negative numbers in red, typeset single entries in bold face or insert replacement text.

	This key is evaluated \emph{after} |assign cell content|. Its semantics is to modify an existing |@cell content| value.

	There may be more than one |postproc cell content| command, if you use |/.append code| or |/.append style| to define them:
\begin{codeexample}[]
% requires \usepackage{eurosym}
\pgfplotstabletypeset[
	column type=r,
	columns={dof,info},
	columns/info/.style={
		% stupid example for multiple postprocessors:
		postproc cell content/.append style={
			/pgfplots/table/@cell content/.add={$\bf}{$},
		},
		postproc cell content/.append style={
			/pgfplots/table/@cell content/.add={}{\EUR{}},
		}
	}]
	{pgfplotstable.example1.dat}
\end{codeexample}
	The code above modifies |@cell content| in two steps. The net effect is to prepend ``|$\bf |'' and to append  ``|$ \EUR|''. It should be noted that |pgfkeys| handles |/.style| and |/.code| in (quasi) the same way -- both are simple code keys and can be used as such. You can combine both with |/.append style| and |/.append code|. Please refer to~\cite[section about pgfkeys]{tikz} for details.

	As in |assign cell content|, the code can evaluate helper macros like |\pgfplotstablerow| to change only particular entries. Furthermore, the postprocessor may depend on the unprocessed cell input (as it has been found in the input file or produced by the loading procedure) and/or the preprocessed cell value. These values are available as
	\begin{itemize}
		\item the key \declareandlabel{@unprocessed cell content} which stores the raw input,
		\item the key \declareandlabel{@preprocessed cell content} which stores the result of the preprocessor,
		\item the key \declareandlabel{@cell content} which contains the result of the typesetting routine,
		\item the shorthand `|#1|' which is also the unprocessed input argument as it has been found in the input table.
	\end{itemize}
	Remember that you can access the key values using 

	|\pgfkeysvalueof{/pgfplots/table/@preprocessed cell content}| 

	at any time.
	
	This allows complete context based formatting options. Please remember that empty strings may appear due to column balancing -- introduce special treatment if necessary.

	There is one special case which occurs if |@cell content| itsself contains the cell separation character `|&|'. In this case, |postproc cell content| is invoked \emph{separately} for each part before and after the ampersand and the ampersand is inserted afterwards. This allows compatibility with special styles which create artificial columns in the output (which is allowed, see |dec sep align|). To allow separate treatment of each part, you can use the macro \declareandlabel{\pgfplotstablepartno}. It is defined only during the evaluation of |postproc cell content| and it evaluates to the current part index (starting with~$0$). If there is no ampersand in your text, the value will always be~$0$.

	This key is evaluated inside of a local \TeX\ group, so any local macro assignments will be cleared afterwards.

	The following example can be used to insert a dash, $-$, in a slope column:
\begin{codeexample}[]
\pgfplotstableset{
	create on use/slopes1/.style=
		{create col/gradient loglog={dof}{error1}}}

\pgfplotstabletypeset[
	columns={dof,error1,slopes1},
	columns/error1/.style={sci,sci zerofill},
	columns/slopes1/.style={
		postproc cell content/.append code={%
			\ifnum\pgfplotstablerow=0
				\pgfkeyssetvalue{/pgfplots/table/@cell content}{\ensuremath{-}}%
			\fi
		}%
	}]
	{pgfplotstable.example1.dat}
\end{codeexample}
Since this may be useful in a more general context, it is available as |empty cells with| style.
\end{codekey}

\begin{stylekey}{/pgfplots/table/empty cells with=\marg{replacement}}
	Appends code to |postproc cell content| which replaces any empty cell with \marg{replacement}.

	If |dec sep align| is active, the replacement will be inserted only for the part before the decimal separator.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/set content=\marg{content}}
	A style which redefines |postproc cell content| to always return the value \marg{content}.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/fonts by sign=\marg{\TeX\ code for positive}\marg{\TeX\ code for negative}}
	Appends code to |postproc cell content| which allows to set fonts for positive and negative numbers.

	The arguments \meta{\TeX\ code for positive} and \meta{\TeX\ code for negative} are inserted right before the typesetted cell content. It is permissable to use both ways to change \LaTeX\ fonts: the |\textbf|\marg{argument} or the |{\bfseries |\marg{argument}|}| way.

% \usepackage{pgfcalendar}
\begin{codeexample}[]
% Requires 
% \usepackage{pgfcalendar}

% plotdata/accounts.dat contains:
%
% date              account1  account2  account3
% 2008-01-03        60        1200      400
% 2008-02-06        120       1600      410
% 2008-03-15        -10       1600      410
% 2008-04-01        1800      500       410
% 2008-05-20        2300      500       410
% 2008-06-15        800       1920      410

\pgfplotstabletypeset[
	columns={date,account1},
	column type=r,
	columns/date/.style={date type={\monthname\ \year}},
	columns/account1/.style={fonts by sign={}{\color{red}}}
]
	{plotdata/accounts.dat}
\end{codeexample}
	In fact, the arguments for this style don't need to be font changes. The style |fonts by sign| inserts several braces and the matching argument into |@cell content|. To be more precise, it results in

	|{|\meta{\TeX\ code for negative}|{|\meta{cell value}|}}| for negative numbers and

	|{|\meta{\TeX\ code for positive}|{|\meta{cell value}|}}| for all other numbers.
\end{stylekey}

\section{Generating Data in New Tables or Columns}
\label{pgfplotstable:createcol}
It is possible to create new tables from scratch or to change tables after they have been loaded from disk.

\subsection{Creating New Tables From Scratch}
\begin{commandlist}{%
	\pgfplotstablenew\oarg{options}\marg{row count}\marg{\textbackslash table},%
	\pgfplotstablenew*\oarg{options}\marg{row count}\marg{\textbackslash table}}
	Creates a new table from scratch. 

	The new table will contain all columns listed in the |columns| key. For |\pgfplotstablenew|, the |columns| key needs to be provided in \oarg{options}. For |\pgfplotstablenew*|, the current value of |columns| is used, no matter where and when it has been set.
	

	Furthermore, there must be |create on use| statements (see the next subsection) for every
	column which shall be generated\footnote{Currently, you need to provide at least one column: the implementation gets confused for completely empty tables. If you do not provide any column name, a dummy column will be created.}. Columns are generated
	independently, in the order of appearance in |columns|. As soon as a column is complete, it can be accessed using any of the basic level access mechanisms. Thus, you can built columns which depend on each other.

	The table will contain exactly \marg{row count} rows. If \marg{row count} is an |\pgfplotstablegetrowsof| statement, that statement will be executed and the resulting number of rows be  used. Otherwise, \marg{row count} will be evaluated as number.
\begin{codeexample}[]
% this key setting could be provided in the document's preamble:
\pgfplotstableset{
	% define how the 'new' column shall be filled:
	create on use/new/.style={create col/set list={4,5,6,7,...,10}}}
% create a new table with 11 rows and column 'new':
\pgfplotstablenew[columns={new}]{11}\loadedtable
% show it:
\pgfplotstabletypeset[empty cells with={---}]\loadedtable
\end{codeexample}

\begin{codeexample}[]
% create a new table with 11 rows and column 'new':
\pgfplotstablenew[
	% define how the 'new' column shall be filled:
	create on use/new/.style={create col/expr={factorial(15+\pgfplotstablerow)}},
	columns={new}]
	{11}
	\loadedtable
% show it:
\pgfplotstabletypeset\loadedtable
\end{codeexample}
\end{commandlist}

\begin{command}{\pgfplotstablevertcat\marg{\textbackslash table1}\marg{\textbackslash table2 or filename}}
\label{table:vertcat}
	Appends the contents of \marg{\textbackslash table2} to \marg{\textbackslash table1} (``vertical cat''). To be more precise, only columns which exist already in \marg{\textbackslash table1} will be appended and every column which exists in \marg{\textbackslash table1} must exist in \marg{\textbackslash table2} (or there must be |alias| or |create on use| specifications to generate them).

	If the second argument is a file name, that file will be loaded from disk. 

	If \marg{\textbackslash table1} does not exist, \marg{\textbackslash table2} will be copied to \marg{\textbackslash table1}.
\begin{codeexample}[code only]
\pgfplotstablevertcat{\output}{datafile1} % loads `datafile1' -> `\output'
\pgfplotstablevertcat{\output}{datafile2} % appends rows of datafile2
\pgfplotstablevertcat{\output}{datafile3} % appends rows of datafile3
\end{codeexample}

	\paragraph{Remark:} The output table \marg{\textbackslash table1} will be defined in the current \TeX\ scope and it will be erased afterwards.
	The current \TeX\ scope is delimited by an extra set of curly braces. However, every \LaTeX\ environment and, unfortunately, the \Tikz\ |\foreach| statement as well, introduce \TeX\ scopes.

	\PGFPlots\ has some some loop statements which do not introduce extra scopes. For example,
\begin{codeexample}[code only]
\pgfplotsforeachungrouped \i in {1,2,...,10} {%
	\pgfplotstablevertcat{\output}{datafile\i} % appends `datafile\i' -> `\output'
}%
\end{codeexample}
	These looping macros are explained in the manual of \PGFPlots, reference section ``Miscellaneous Commands''
\end{command}

\begin{command}{\pgfplotstableclear\marg{\textbackslash table}}
	Clears a table. Note that it is much more reliable to introduce extra curly braces `|{ ... }|' around table operations -- these braces define the scope of a variable (including tables).
\end{command}

\subsection{Creating New Columns From Existing Ones}
\begin{command}{\pgfplotstablecreatecol\oarg{options}\marg{new col name}\marg{\textbackslash table}}
Creates a new column named \marg{new col name} and appends it to an already existing table \marg{\textbackslash table}.

End users probably don't need to use |\pgfplotstablecreatecol| directly at all -- there is the high--level framework |create on use| which invokes it internally and can be used with simple key--value assignments (see below). However, this documentation explains how to use values of existing columns to fill new cells.

This command offers a flexible framework to generate new columns. It has been designed to create new columns using the already existing values -- for example using logical or numerical methods to combine existing values. It provides fast access to a row's value, the previous row's value and the next row's value.

The following documentation is for all who want to \emph{write} specialised columns. It is not particularly difficult; it is just technical and it requires some knowledge of |pgfkeys|. If you don't like it, you can resort to predefined column generation styles - and enable those styles in \marg{options}.

The column entries will be created using the command key \pgfmanualpdflabel{/pgfplots/table/create col/assign}{\declaretext{create col/assign}}. It will be invoked for every row of the table.
It is supposed to assign contents to \pgfmanualpdflabel{/pgfplots/table/create col/next content}{\declaretext{create col/next content}}.
During the evaluation, the macro |\thisrow|\marg{col name} 
expands to the current row's value of the column identified by \marg{col name}.
Furthermore, |\nextrow|\marg{col name} expands to the \emph{next} row's
value of the designated column and |\prevrow|\marg{col name} expands to the value of the \emph{previous} row.

So, the idea is to simply redefine the command key |create col/assign| in such a way that it fills new cells as desired.

Two special |assign| routines are available for the first and last row: The contents for the \emph{last} row is computed with \pgfmanualpdflabel{/pgfplots/table/create col/assign last}{\declaretext{create col/assign last}}. Its semantics is the same. The contents for the \emph{first} row is computed with \pgfmanualpdflabel{/pgfplots/table/create col/assign first}{\declaretext{create col/assign first}} to simplify special cases here. These first and last commands are optional, their default is to invoke the normal |assign| routine.

The evaluation of the |assign| keys is done in local \TeX\ groups (i.e. any local definitions will be cleared afterwards).

The following macros are useful during cell assignments:
\begin{enumerate}
	\item \declareandlabel{\prevrow}\marg{col name} / \declareandlabel{\getprevrow}\marg{col name}\marg{\textbackslash macro}

	These two routines return the value stored in the \emph{previous} row of the designated column \marg{col name}. The |get| routine stores it into \meta{\textbackslash macro}.

	The argument \meta{col name} has to denote either an existing column name or one for which an |alias/|\meta{col name} exists.

	\item \declareandlabel{\thisrow}\marg{col name} / \declareandlabel{\getthisrow}\marg{col name}\marg{\textbackslash macro}

	These two routines return the \emph{current} row's value stored in the designated column. The |get| routine stores it into \meta{\textbackslash macro}.

	The argument \meta{col name} has to denote either an existing column name or one for which an |alias/|\meta{col name} exists.

	\item \declareandlabel{\nextrow}\marg{col name} / \declareandlabel{\getnextrow}\marg{col name}\marg{\textbackslash macro}

	These two routines return the \emph{next} row's value.

	The argument \meta{col name} has to denote either an existing column name or one for which an |alias/|\meta{col name} exists.

	\item |\pgfplotstablerow| and |\pgfplotstablerows| which contain the current row's index and the total number of rows, respectively. See page~\pageref{pgfplotstable:page:tablerow} for details.
	\item \declareandlabel{\pgfmathaccuma} and \declareandlabel{\pgfmathaccumb} can be used to transport intermediate results.
	Both maintain their value from one column assignment to the next. All other local variables will be deleted after leaving the assignment routines. The initial value is the empty string for both of them unless they are already initialised by column creation styles.
	\item \declareandlabel{\pgfplotstablename} a macro containing the name of the currently processed table (i.e.\ it contains the second argument of |\pgfplotstablecreatecol|).
	\item commands which are valid throughout every part of this package, for example |\pgfplotstablerow| to get the current row index or |\pgfplotstablerows| to get the total number of rows.
\end{enumerate}
The \marg{col name} is expected to be a \emph{physical} column name, no alias or column index is allowed (unless column indices and column names are the same).

The following example takes our well-known input table and creates a copy of the |level| column. Furthermore, it produces a lot of output to show the available macros. Finally, it uses |\pgfkeyslet| to assign the contents of the resulting |\entry| to |next content|.
\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}\loadedtable
\pgfplotstablecreatecol[
	create col/assign/.code={%
		\getthisrow{level}\entry
		\getnextrow{level}\nextentry
		\edef\entry{thisrow=\entry; nextrow=\nextentry. 
			(\#\pgfplotstablerow/\pgfplotstablerows)}%
		\pgfkeyslet{/pgfplots/table/create col/next content}\entry
	}]
	{new}\loadedtable

\pgfplotstabletypeset[
	column type=l,
	columns={level,new},
	columns/new/.style={string type}
]\loadedtable
\end{codeexample}

There is one more speciality: you can use |columns=|\marg{column list} to reduce the runtime complexity of this command. This works only if the |columns| key is provided directly into \marg{options}. In this case |\thisrow| and its variants are only defined for those columns listed in the |columns| value.

\paragraph{Limitations.} Currently, you can only access three values of one column at a time: the current row, the previous row and the next row. Access to arbitrary indices is not (yet) supported.

\paragraph{Remark:} If you'd like to create a table from scratch using this command (or the related |create on use| simplification), take a look at |\pgfplotstablenew|.

The default implementation of |assign| is to produce empty strings. The default implementation of |assign last| is to invoke |assign|, so in case you never really use the next row's value, you won't need to touch |assign last|. The same holds for |assign first|.
\end{command}

\begin{pgfplotstablecreateonusekey}
	Allows ``lazy creation'' of the column \meta{col name}. Whenever the column \meta{col name} is queried by name, for example in an |\pgfplotstabletypeset| command, and such a column does not exist already, it is created on-the-fly.

\begin{codeexample}[narrow]
% requires \usepackage{array}
\pgfplotstableset{% could be used in preamble
	create on use/quot1/.style=
		{create col/quotient={error1}}}

\pgfplotstabletypeset[
	columns={error1,quot1},
	columns/error1/.style={sci,sci zerofill},
	columns/quot1/.style={dec sep align}]
{pgfplotstable.example1.dat}
\end{codeexample}
	The example above queries |quot1| which does not yet exist in the input file. Therefor, it is checked whether a |create on use| style for |quot1| exists. This is the case, so it is used to create the missing column. The |create col/quotient| key is discussed below; it computes quotients of successive rows in column |error1|.

	A |create on use| specification is translated into 
	
	|\pgfplotstablecreatecol[|\meta{create options}|]|\marg{col name}\marg{the table},

	or, equivalently, into

	|\pgfplotstablecreatecol[|create on use/\meta{col name}|]|\marg{col name}\marg{the table}.

	This feature allows some lazyness, because you can omit the lengthy table modifications. However, lazyness may cost something: in the example above, the generated column will be \emph{lost} after returning from |\pgfplotstabletypeset|.

	The |create on use| has higher priority than |alias|.

	In case \meta{col name} contains characters which are required for key settings, you need to use braces around it: ``|create on use/{name=wi/th,special}/.style={...}|''.

	More examples for |create on use| are shown below while discussing the available column creation styles.

	Note that |create on use| is also available within \PGFPlots, in |\addplot table| when used together with the |read completely| key.
\end{pgfplotstablecreateonusekey}

\subsection{Predefined Column Generation Methods}
The following keys can be used in both |\pgfplotstablecreatecol| and the easier |create on use| frameworks.

\subsubsection{Acquiring Data Somewhere}
\begin{stylekey}{/pgfplots/table/create col/set=\marg{value}}
	A style for use in column creation context which creates a new column and writes \marg{value} into each new cell. The value is written as string (verbatim).
\begin{codeexample}[]
\pgfplotstableset{
	create on use/my new col/.style={create col/set={--empty--}},
	columns/my new col/.style={string type}
}

\pgfplotstabletypeset[
	columns={level,my new col},
]{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/set list=\marg{comma-separated-list}}
	A style for use in column creation context which creates a new column consisting of the entries in \marg{comma-separated-list}. The value is written as string (verbatim).

	The \marg{comma-separated-list} is processed via \Tikz's |\foreach| command, that means you can use |...| expressions to provide number (or character) ranges.
\begin{codeexample}[]
\pgfplotstableset{
	create on use/my new col/.style={
		create col/set list={A,B,C,4,50,55,...,100}},
	columns/my new col/.style={string type}
}

\pgfplotstabletypeset[
	columns={level,my new col},
]{pgfplotstable.example1.dat}
\end{codeexample}
	\noindent The new column will be padded or truncated to the required number of rows. If the list does not contain enough elements, empty cells will be produced.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/copy=\marg{column name}}
	A style for use in column creation context which simply copies the existing column \marg{column name}.
\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={create col/copy={level}}
}

\pgfplotstabletypeset[
	columns={level,new},
	columns/new/.style={column name=Copy of level}
]{pgfplotstable.example1.dat}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/copy column from table=\marg{file name or \textbackslash macro}\marg{column name}}
	A style for use in column creation context which creates a new column consisting of the entries in \marg{column name} of the provided table. The argument may be either a file name or an already loaded table (i.e. a \meta{\textbackslash macro} as returned by |\pgfplotstableread|).

	You can use this style, possibly combined with |\pgfplotstablenew|, to merge one common sort of column from different tables into one large table.
	
	The cell values are written as string (verbatim).

	\noindent The new column will be padded or truncated to the required number of rows. If the list does not contain enough elements, empty cells will be produced.
\end{stylekey}


\subsubsection{Mathematical Operations}

\begin{key}{/pgf/fpu=\mchoice{true,false} (initially true)}
\index{Precision}
	Before we start to describe the column generation methods, one word about the math library. The core is always the \PGF\ math engine written by Mark Wibrow and Till Tantau. However, this engine has been written to produce graphics and is not suitable for scientific computing.
	
	I added a high-precision floating point library to \PGF\ which will be part of releases newer than \PGF\ $2.00$. It offers the full range of IEEE double precision computing in \TeX. This FPU is also part of \PGFPlotstable, and it is activated by default for |create col/expr| and all other predefined mathematical methods.

	The FPU won't be active for newly defined numerical styles (although it is active for the predefined mathematical expression parsing styles like |create col/expr|). If you want to add own routines or styles, you will need to use
\begin{codeexample}[code only]
\pgfkeys{/pgf/fpu=true}
\end{codeexample}
	\noindent in order to activate the extended precision. The standard math parser is limited to fixed point numbers in the range $\pm 16384.00000$.
\end{key}

\begin{stylekey}{/pgfplots/table/create col/expr=\marg{math expression}}
	A style for use in |\pgfplotstablecreatecol| which uses \marg{math expression} to assign contents for the new column.

\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={
		create col/expr={\thisrow{level}*2}}
}

\pgfplotstabletypeset[
	columns={level,new},
	columns/new/.style={column name=$2\cdot $level}
]{pgfplotstable.example1.dat}
\end{codeexample}
	The macros |\thisrow|\marg{col name} and |\nextrow|\marg{col name} can be used to use values of the existing table.

	Please see |\pgfplotstablecreatecol| for more information.

	\paragraph{Accumulated columns:} The |expr| style initialises |\pgfmathaccuma| to |0| before its first column. Whenever it computes a new column value, it redefines |\pgfmathaccuma| to be the result. That means you can use |\pgfmathaccuma| inside of \marg{math expression} to accumulate columns. See |create col/expr accum| for more details.

	\paragraph{About the precision and number range:}\index{Precision}\index{Floating Point Unit} Starting with version 1.2, |expr| uses a floating point unit. The FPU provides the full data range of scientific computing with a relative precision between $10^{-4}$ and $10^{-6}$. The |/pgf/fpu| key provides some more details. 
	
	\paragraph{Accepted operations:} The math parser of \PGF, combined with the FPU, provides the following function and operators:

	|+|, |-|, |*|, |/|, |abs|, |round|, |floor|, |mod|, |<|, |>|, |max|, |min|, |sin|, |cos|, |tan|, |deg| (conversion from radians to degrees), |rad| (conversion from degrees to radians), |atan|, |asin|, |acos|, |cot|, |sec|, |cosec|, |exp|, |ln|, |sqrt|, the constanst |pi| and |e|, |^| (power operation), |factorial|\footnote{Starting with \PGF\ versions newer than $2.00$, you can use the postfix operator \texttt{!} instead of \texttt{factorial}.}, |rand| (random between $-1$ and $1$), |rnd| (random between $0$ and $1$), number format conversions |hex|, |Hex|, |oct|, |bin| and some more. The math parser has been written by Mark Wibrow and Till Tantau~\cite{tikz}, the FPU routines have been developed as part of \PGFPlots. The documentation for both parts can be found in~\cite{tikz}. \textbf{Attention:} Trigonometric functions work with degrees, not with radians!

\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/expr accum=\marg{math expression}\marg{accum initial}}
	A variant of |create col/expr| which also allows to define the initial value of |\pgfmathaccuma|. The case \marg{accum initial}=|0| is \emph{equivalent} to |expr=|\marg{math expression}.

\begin{codeexample}[]
\pgfplotstableset{
	create on use/new/.style={
		create col/expr={\pgfmathaccuma + \thisrow{level}}},
	create on use/new2/.style={
		create col/expr accum={\pgfmathaccuma * \thisrow{level}}{1}%<- start with `1'
	}
}

\pgfplotstabletypeset[
	columns={level,new,new2},
	columns/new/.style={column name=$\sum$level},
	columns/new2/.style={column name=$\prod$level}
]{pgfplotstable.example1.dat}
\end{codeexample}
The example creates two columns: the |new| column is just the sum of each value in the \meta{level} column (it employs the default |\pgfmathaccuma=0|). The |new2| column initialises |\pgfmathaccuma=100| and then successively subtracts the value of \meta{level}.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/quotient=\marg{column name}}
	A style for use in |\pgfplotstablecreatecol| which computes the quotient $c_i := m_{i-1} / m_i$ for every entry $i = 1,\dotsc, (n-1)$ in the column identified with \marg{column name}. The first value $c_0$ is kept empty.

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example, in preamble:
	create on use/quot1/.style={create col/quotient=error1},
	create on use/quot2/.style={create col/quotient=error2},
	columns={error1,error2,quot1,quot2},
	%
	% display styles:
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/quot1/.style={dec sep align},
	columns/quot2/.style={dec sep align}
}

\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-7}$ ($7$ significant digits in the mantisse).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/iquotient=\marg{column name}}
	Like |create col/quotient|, but the quotient is inverse.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/dyadic refinement rate=\marg{column name}}
	A style for use in |\pgfplotstablecreatecol| which computes the convergence rate $\alpha$ of the data in column \marg{column name}. The contents of \marg{column name} is assumed to be something like $e_i(h_i) = O(h_i^\alpha)$. Assuming a dyadic refinement relation from one row to the next, $h_i = h_{i-1}/2$, we have $h_{i-1}^\alpha / (h_{i-1}/2)^\alpha = 2^\alpha$, so we get $\alpha$ using 
	\[ c_i := \log_2\left( \frac{e_{i-1}}{e_i} \right). \]
	The first value $c_0$ is kept empty.

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstabletypeset[% here, configuration options apply only to this single statement:
	create on use/rate1/.style={create col/dyadic refinement rate={error1}},
	create on use/rate2/.style={create col/dyadic refinement rate={error2}},
	columns={error1,error2,rate1,rate2},
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/rate1/.style={dec sep align},
	columns/rate2/.style={dec sep align}]
	{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-6}$ ($6$ significant digits in the mantisse).
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/idyadic refinement rate=\marg{column name}}
	As |create col/dyadic refinement rate|, but the quotient is inverse.
\end{stylekey}

\begin{keylist}{
	/pgfplots/table/create col/gradient=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient loglog=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient semilogx=\marg{col x}\marg{col y},
	/pgfplots/table/create col/gradient semilogy=\marg{col x}\marg{col y}}
	A style for |\pgfplotstablecreatecol| which computes piecewise gradients $(y_{i+1} - y_i) / (x_{i+1} - x_i )$ for each row. The $y$ values are taken out of column \marg{col y} and the $x$ values are taken from \marg{col y}.
	
	The logarithmic variants apply the natural logarithm, $\log(\cdot)$, to its argument before starting to compute differences. More precisely, the |loglog| variant applies the logarithm to both, $x$ and $y$, the |semilogx| variant applies the logarithm only to~$x$ and the |semilogy| variant applies the logarithm only to~$y$.
	
\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example in preamble:
	create on use/slopes1/.style={create col/gradient loglog={dof}{error1}},
	create on use/slopes2/.style={create col/gradient loglog={dof}{error2}},
	columns={dof,error1,error2,slopes1,slopes2},
	% display styles:
	columns/dof/.style={int detect},
	columns/error1/.style={sci,sci zerofill},
	columns/error2/.style={sci,sci zerofill},
	columns/slopes1/.style={dec sep align},
	columns/slopes2/.style={dec sep align}
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}

\begin{codeexample}[]
% requires \usepackage{array}
\pgfplotstableset{% configuration, for example in preamble:
	create on use/slopes1/.style={create col/gradient semilogy={level}{error1}},
	columns={level,error1,slopes1},
	% display styles:
	columns/level/.style={int detect},
	columns/error1/.style={sci,sci zerofill,sci subscript},
	columns/slopes1/.style={dec sep align}
}
\pgfplotstabletypeset{pgfplotstable.example1.dat}
\end{codeexample}
	This style employs methods of the floating point unit, that means it works with a relative precision of about $10^{-6}$ ($6$ significant digits in the mantisse).
\end{keylist}

\begin{stylekey}{/pgfplots/table/create col/linear regression=\marg{key-value-config}}%
	Computes a linear (least squares) regression $y(x) = a \cdot x + b$ using the sample data $(x_i,y_i)$ which has to be specified inside of \meta{key-value-config}.

\begin{codeexample}[pre={\vbox\bgroup\hsize=3cm},post=\egroup]
% load table from somewhere:
\pgfplotstableread[row sep=\\]{
	x y\\
	1 1 \\
	2 4\\
	3 9\\
	4 16\\
	5 25\\
	6 36\\
}\loadedtbl

% create the `regression' column:
\pgfplotstablecreatecol[linear regression]
	{regression}
	{\loadedtbl}
% store slope
\xdef\slope{\pgfplotstableregressiona}

\pgfplotstabletypeset\loadedtbl\\

The slope is `\slope'.
\end{codeexample}
	\noindent The example above loads a table from inline data, appends a column named `|regression|' and typesets it. Since no \meta{key-value-config} has been provided, |x=[index]0| and |y=[index]1| will be used. The |\xdef\slope{...}| command stores the `$a$' value of the regression line into a newly defined macro `|\slope|'\footnote{The \texttt{\textbackslash xdef} means ``global expanded definition'': it expands the argument until it can't be expanded any further and assigns a (global) name to the result. See any \TeX\ book for details.}.

	The complete documentation for this feature has been moved to \PGFPlots\ due to its close relation to plotting. Please refer to the \PGFPlots\ manual coming with this package.
\end{stylekey}

\begin{stylekey}{/pgfplots/table/create col/function graph cut y=\marg{cut value}\marg{common options}\marg{one key-value set for each plot}}
	A specialized style for use in |create on use| statements which computes cuts of (one or more) discrete plots $y(x_1), \dotsc, y(x_N)$ with a fixed \marg{cut value}. The $x_i$ are written into the table's cells.

	In a cost--accuracy plot, this feature allows to extract the cost for fixed accuracy. The dual feature with |cut x| allows to compute the accuracy for fixed cost.
	
	\pgfplotsset{anchor=center,/tikz/baseline}
\begin{codeexample}[]
\pgfplotstablenew[
	create on use/cut/.style={create col/function graph cut y=
		{2.5e-4} % search for fixed L2 = 2.5e-4
		{x=Basis,y=L2,ymode=log,xmode=log} % double log, each function is L2(Basis)
		% now, provide each single function f_i(Basis):
		{{table=plotdata/newexperiment1.dat},{table=plotdata/newexperiment2.dat}}
	},
	columns={cut}]
	{2} 
	\loadedtable

% Show the data:
\pgfplotstabletypeset{\loadedtable}

\begin{tikzpicture}
\begin{loglogaxis}
	\addplot table[x=Basis,y=L2] {plotdata/newexperiment1.dat};
	\addplot table[x=Basis,y=L2] {plotdata/newexperiment2.dat};
	\draw[blue!30!white] (axis cs:1,2.5e-4) -- (axis cs:1e5,2.5e-4);
	\node[pin=-90:{$x=53.66$}] at (axis cs:53.66,2.5e-4) {};
	\node[pin=45:{$x=601.83$}] at (axis cs:601.83,2.5e-4) {};
\end{loglogaxis}
\end{tikzpicture}
\end{codeexample}
	In the example above, we are searching for $x_1$ and $x_2$ such that $f_1(x_1) = \pgfmathprintnumber{2.5e-4}$ and $f_2(x_2) =\pgfmathprintnumber{2.5e-4}$. On the left is the automatically computed result. On the right is a problem illustration with proper annotation using \PGFPlots\ to visualize the results.
	The \marg{cut value} is set to |2.5e-4|. The \marg{common options} contain the problem setup; in our case logarithmic scales and column names. The third argument is a comma-separated-list. Each element $i$ is a set of keys describing how to get $f_i(\cdot)$.

	During both, \marg{common options} and \marg{one key-value set for each plot}, the following keys can be used:
	\begin{itemize}
		\item \declareandlabel{table}|=|\marg{table file or \textbackslash macro}: either a file name or an already loaded table where to get the data points,
		\item \declareandlabel{x}|=|\marg{col name}: the column name of the $x$ axis,
		\item \declareandlabel{y}|=|\marg{col name}: the column name of the $y$ axis.
		\item \declareandlabel{foreach}|=|\marg{\textbackslash foreach loop head}\marg{file name pattern}
			This somewhat advanced syntax allows to collect tables in a loop automatically:

\begin{codeexample}[]
\pgfplotstablenew[
	% same as above...
	create on use/cut/.style={create col/function graph cut y=
		{2.5e-4}% search for fixed L2 = 2.5e-4
		{x=Basis,y=L2,ymode=log,xmode=log,
		 foreach={\i in {1,2}}{plotdata/newexperiment\i.dat}}%
		{}% just leave this empty.
	},
	columns={cut}]
	{2} 
	\loadedtable
% Show the data:
\pgfplotstabletypeset{\loadedtable}
\end{codeexample}
		\PGFPlotstable\ will call |\foreach |\meta{\textbackslash foreach loop head} and it will expand \marg{file name pattern} for every iteration. For every iteration, a simpler list entry of the form 

		|table=|\marg{expanded pattern}|,x=|\marg{value of x}|,y=|\marg{value of y}

		will be generated.

		It is also possible to provide |foreach=| inside of \marg{one key-value set for each plot}. The |foreach| key takes precedence over |table|. Details about the accepted syntax of |\foreach| can be found in the \pgfname\ manual.
	\end{itemize}
	The keys \declareandlabel{xmode} and \declareandlabel{ymode} can take either |log| or |linear|. All mentioned keys have the common key path 

	\textcolor{red!75!black}{\texttt{/pgfplots/table/create col/function graph cut/}}.
\end{stylekey}
\begin{stylekey}{/pgfplots/table/create col/function graph cut x=\marg{cut value}\marg{common options}\marg{one key-value set for each plot}}
	As above, just with $x$ and $y$ exchanged.
\end{stylekey}

\section{Miscellaneous}
\subsection{Writing (Modified) Tables To Disk}
\begin{key}{/pgfplots/table/outfile=\marg{file name} (initially empty)}
	Writes the completely processed table as \TeX\ file to \marg{file name}. This key is described in all detail on page~\pageref{page:outfile}.
\end{key}

\begin{command}{\pgfplotstablesave\oarg{options}\marg{\textbackslash macro or input file name}\marg{output file name}}
	This command takes a table and writes it to a new data file (without performing any typesetting).

	If the first argument is a file name, that file is loaded first.

	This command simply invokes |\pgfplotstabletypeset| with cleared output parameters. That means any of the column creation methods apply here as well, including any postprocessing steps (without the final typesetting).

	|\pgfplotstablesave| uses the keys |reset styles| and |disable rowcol styles| to clear any typesetting related options.
	
	Furthermore, it sets |string type| to allow verbatim output. You may want to use |numeric as string type| instead in case you only have numerical data -- this will display integers resulting from arithmetics not in scientific notation\footnote{Note however, that |string type| doesn't round or truncate integers as well, even though they are displayed as floats.}.
\begin{codeexample}[]
\pgfplotstablesave[
	create on use/postproc1/.style={create col/dyadic refinement rate=error1},
	columns={dof,error1,postproc1}
]
	{pgfplotstable.example1.dat}
	{pgfplotstable.example1.out.dat}
\end{codeexample}
Now, |pgfplotstable.example1.out.dat| is
\lstinputlisting[basicstyle=\ttfamily\footnotesize,tabsize=8]{pgfplotstable.example1.out.dat}

You can use the |col sep| key inside of \meta{options} to define a column separator for the output file. In case you need a different input column separator, use |in col sep| instead of |col sep|.

\paragraph{Remarks}
\begin{itemize}
	\item 
Empty cells will be filled with |{}| if |col sep=space|. Use the |empty cells with| style to change that.
	\item  Use |disable rowcol styles=false| inside of \meta{options} if you need to change column/row based styles.
\end{itemize}
\end{command}

\subsection{Miscellaneous Keys}
\begin{key}{/pgfplots/table/disable rowcol styles=\mchoice{true,false} (initially false)}
	Set this to |true| if |\pgfplotstabletypeset| shall \emph{not} set any styles which apply only to specific columns or only to specific rows.

	This disables the styles
	\begin{itemize}
		\item |columns/|\meta{column name},
		\item |display columns/|\meta{column index},
		\item |every col no |\meta{column index},
		\item |every row no |\meta{row index}.
	\end{itemize}
\end{key}

\begin{key}{/pgfplots/table/reset styles}
	Resets all table typesetting styles which do not explicitly depend on column or row names and indices. The affected styles are
	\begin{itemize}
		\item |every table|,
		\item |every even row|, |every odd row|, |every even column|, |every odd column|,
		\item |every first column|, |every last column|, |every first row|, |every last row|,
		\item |every head row|,
		\item |postproc cell content|, |preproc cell content|.
	\end{itemize}
	In case you want to reset all, you should also consider the key |disable rowcol styles|.
\end{key}

\subsection{A summary of how to define and use styles and keys}
This section summarizes features of |pgfkeys|. The complete documentation can be found in the \pgfname\ manual,~\cite{tikz}.
\begin{handler}{{.style}=\marg{key-value-list}}
	Defines or redefines a style \meta{key}. A style is a normal key which will set all options in \marg{key-value-list} when it is set.

	Use	|\pgfplotstableset{|\meta{key}|/.style={|\meta{key-value-list}|}}| to (re-) define a style \meta{key} in the namespace |/pgfplots/table|.
\end{handler}

\begin{handler}{{.append style}=\marg{key-value-list}}
	Appends \marg{key-value-list} to an already existing style \meta{key}. This is the preferred method to change the predefined styles: if you only append, you maintain compatibility with future versions.

	Use	|\pgfplotstableset{|\meta{key}|/.append style={|\meta{key-value-list}|}}| to append \marg{key-value-list} to the style \meta{key}. This will assume the prefix |/pgfplots/table|.
\end{handler}

\begin{handler}{{.initial}=\marg{value}}
	Defines a new \meta{key} and assigns \meta{value}.
\end{handler}

\begin{handler}{{.add}=\marg{before}\marg{after}}
	Changes \meta{key} by prepending \meta{before} and appending \meta{after}.
\begin{codeexample}[]
\pgfplotstableset{columns={a column}}
`\pgfkeysvalueof{/pgfplots/table/columns}';
\pgfplotstableset{columns/.add={}{,another}}
`\pgfkeysvalueof{/pgfplots/table/columns}';
\pgfplotstableset{columns/.add={}{,and one more}}
`\pgfkeysvalueof{/pgfplots/table/columns}'.
\end{codeexample}
	This can be used inside of |\pgfplotsinvokeforeach| or similar (ungrouped!) loop constructs.
\end{handler}

\begin{handler}{{.code}=\marg{\TeX\ code}}
	Occasionally, the \PGFPlots\ user interface offers to replace parts of its routines. This is accomplished using so called ``code keys''. What it means is to replace the original key and its behavior with new \marg{\TeX\ code}. Inside of \marg{\TeX\ code}, any command can be used. Furthermore, the |#1| pattern will be the argument provided to the key.

\begin{codeexample}[]
\pgfplotsset{
	My Code/.code={This is a pgfkeys feature. Argument=`#1'}}
\pgfplotsset{My Code={is here}}
\end{codeexample}
	The example defines a (new) key named |My Code|. Essentially, it is nothing else but a |\newcommand|, plugged into the key-value interface. The second statement ``invokes'' the code key.	
\end{handler}

\begin{handler}{{.append code}=\marg{\TeX\ code}}
	Appends \marg{\TeX\ code} to an already existing |/.code| key named \meta{key}. 
\end{handler}


\begin{handler}{{.code 2 args}=\marg{\TeX\ code}}
	As |/.code|, but this handler defines a key which accepts two arguments. When the so defined key is used, the two arguments are available as |#1| and |#2|.
\end{handler}


\subsection{Plain \TeX\ and Con\TeX t support}
\label{sec:pgfplotstable:context}
The table code generator is initialised to produce \LaTeX\ |tabular| environments. However, it only relies on~`|&|' being the column separator and~`|\\|' the row terminator. The |column type| feature is more or less specific to |tabular|, but you can disable it completely. Replace |begin table| and |end table| with appropriate \TeX- or Con\TeX t commands to change it. If you have useful default styles (or bug reports), let me know.

\subsection{Basic Level Table Access and Modification}
\PGFPlotstable\ provides several methods to access and manipulate tables at an elementary level.

Please keep in mind that \PGFPlotstable\ has been written as tool for table visualization. As such, it has been optimized for the case of relatively few rows (although it may have a lot of columns). The runtime for table creation and modification is currently $O(N^2)$ where $N$ is the number of rows\footnote{The runtime for \texttt{plot table} is linear in the number of rows using a special routine.}. This is completely acceptable for tables with few rows because \TeX\ can handle those structures relatively fast. Keep your tables small! \PGFPlotstable\ is \emph{not} a tool for large-scale matrix operations.

Tables are always stored as a sequence of column vectors. Therefore, iteration over all values in one column is simple whereas iteration over all values in one row is complicated and expensive.

\begin{command}{\pgfplotstableforeachcolumn\meta{table}\textbackslash as\marg{\textbackslash macro}\marg{code}}
	Iterates over every column name of \meta{table}. The \meta{\textbackslash macro} will be set to the currently visited column name. Then, \marg{code} will be executed. During \marg{code}, |\pgfplotstablecol| denotes the current column index (starting with 0).
\begin{codeexample}[]
\begin{minipage}{0.8\linewidth}
\pgfplotstableread{pgfplotstable.example1.dat}\loadedtable
\pgfplotstableforeachcolumn\loadedtable\as\col{%
	column name is `\col'; index is\pgfplotstablecol;\par
}
\end{minipage}
\end{codeexample}

	This routine does not introduce \TeX\ groups, variables inside of \marg{code} are not scoped.
\end{command}

\begin{command}{\pgfplotstableforeachcolumnelement\meta{column name}\textbackslash of\meta{table}\textbackslash as\meta{\textbackslash cellcontent}\marg{code}}
	Reports every table cell $t_{ij}$ for a fixed column $j$ in read-only mode.

	For every cell in the column named \meta{column name}, \marg{code} will be executed. During this invocation, the macro \meta{\textbackslash cellcontent} will contain the cell's content and |\pgfplotstablerow| will contain the current row's index.
\begin{codeexample}[]
\begin{minipage}{0.8\linewidth}
\pgfplotstableread{pgfplotstable.example1.dat}\loadedtable
\pgfplotstableforeachcolumnelement{error1}\of\loadedtable\as\cell{%
	I have now cell element `\cell' at row index `\pgfplotstablerow';\par
}
\end{minipage}
\end{codeexample}
	The argument \meta{column name} can also be a column index. In that case, it should contain |[index]|\meta{integer}, for example |[index]4|. Furthermore, column aliases and column which should be generated on-the-fly (see |create on use|) can be used for \meta{column name}.

	This routine does not introduce \TeX\ groups, variables inside of \marg{code} are not scoped.
\end{command}

\begin{command}{\pgfplotstablemodifyeachcolumnelement\meta{column name}\textbackslash of\meta{table}\textbackslash as\meta{\textbackslash cellcontent}\marg{code}}
	A routine which is similar to |\pgfplotstableforeachcolumnelement|,
	but any changes of \meta{\textbackslash cellcontent} which might occur during \marg{code} will be written back into the respective cell.

\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}\loadedtable
\pgfplotstablemodifyeachcolumnelement{error1}\of\loadedtable\as\cell{%
	\edef\cell{\#\pgfplotstablerow: \cell}%
}
\pgfplotstabletypeset[columns=error1,string type]{\loadedtable}
\end{codeexample}

	If \marg{column name} is a column alias or has been created on-the-fly, a new column named \meta{column name} will be created.
\end{command}

\begin{command}{\pgfplotstablegetelem\marg{row}\marg{col}\textbackslash of\meta{table}}
	Selects a single table element at row \marg{row} and column \marg{col}. The second argument has the same format as that described in the last paragraph: it should be a column name or a column index (in which case it needs to be written as |[index]|\meta{number}).

	The return value will be written to |\pgfplotsretval|.
\begin{codeexample}[]
\pgfplotstableread{pgfplotstable.example1.dat}{\loadedtable}
\pgfplotstablegetelem{4}{error1}\of{\loadedtable}
The value (4,error1) is `\pgfplotsretval'. 

\pgfplotstablegetelem{2}{[index]0}\of{\loadedtable}
The value (2,0) is `\pgfplotsretval'.
\end{codeexample}

	\paragraph{Attention:} If possible, avoid using this command inside of loops. It is quite slow.
\end{command}

\begin{commandlist}{%
	\pgfplotstablegetrowsof\marg{file name or \textbackslash loadedtable},
	\pgfplotstablegetcolsof\marg{file name or \textbackslash loadedtable}}
	Defines |\pgfplotsretval| to be the number of rows in a table\footnote{It will also assign \texttt{\textbackslash pgfmathresult} to the same value.}. The argument may be either a file name or an already loaded table (the \meta{\textbackslash macro} of |\pgfplotstableread|).
\end{commandlist}


\begin{command}{\pgfplotstablevertcat\marg{\textbackslash table1}\marg{\textbackslash table2 or filename}}
	See page \pageref{table:vertcat} for details about this command.
\end{command}

\begin{command}{\pgfplotstablenew\oarg{options}\marg{row count}\marg{\textbackslash table}}
	See section~\ref{pgfplotstable:createcol} for details about this command.
\end{command}
\begin{command}{\pgfplotstablecreatecol\oarg{options}\marg{row count}\marg{\textbackslash table}}
	See section~\ref{pgfplotstable:createcol} for details about this command.
\end{command}
	
\begin{commandlist}{%
	\pgfplotstabletranspose\oarg{options}\marg{\textbackslash outtable}\marg{\textbackslash table or filename},%
	\pgfplotstabletranspose*\oarg{options}\marg{\textbackslash outtable}\marg{\textbackslash table or filename}}%
	Defines \meta{\textbackslash outtable} to be the transposed of \marg{\textbackslash table of filename}. The input argument can be either a file name or an already loaded table.

	The version with `|*|' is only interesting in conjunction with the |columns| option, see below.

\begin{codeexample}[]
\pgfplotstabletypeset[string type]{pgfplotstable.example3.dat}
\end{codeexample}

\begin{codeexample}[]
\pgfplotstabletranspose\loadedtable{pgfplotstable.example3.dat}
\pgfplotstabletypeset[string type]\loadedtable
\end{codeexample}

	The optional argument \meta{options} can contain options which influence the transposition:
	\begin{pgfplotskey}{table/colnames from=\marg{colname} (initially empty)}
		Inside of |\pgfplotstabletranspose|, this key handles how to define output column names.
		
		If \marg{colname} \emph{is} empty (the initial value), the output column names will simply be the old row indices, starting with~$0$.

		If \marg{colname} is not empty, it denotes an input column name whose cell values will make up the output column names:
\begin{codeexample}[]
\pgfplotstabletranspose[colnames from=c]\loadedtable{pgfplotstable.example3.dat}
\pgfplotstabletypeset[string type]\loadedtable
\end{codeexample}
		The argument \meta{colname} won't appear as cell contents. It is an error if the the cells in \meta{colname} don't yield unique column names.
	\end{pgfplotskey}

	\begin{pgfplotskey}{table/input colnames to=\marg{name} (initially colnames)}
		Inside of |\pgfplotstabletranspose|, this key handles what to do with \emph{input} column names.

		This key will create a further column named \meta{name} which will be filled with the input column names (as string type).
\begin{codeexample}[]
\pgfplotstabletranspose[input colnames to=Input]\loadedtable{pgfplotstable.example3.dat}
\pgfplotstabletypeset[string type]\loadedtable
\end{codeexample}
		Set \meta{name} to the empty string to disable this column.
\begin{codeexample}[]
\pgfplotstabletranspose[input colnames to=]\loadedtable{pgfplotstable.example3.dat}
\pgfplotstabletypeset[string type]\loadedtable
\end{codeexample}
	\end{pgfplotskey}

	\begin{pgfplotskey}{table/columns=\marg{list} (initially empty)}
		Inside of |\pgfplotstabletranspose|, this key handles which input columns shall be considered for the transposition.

		If \meta{list} is empty, all columns of the input table will be used (which is the initial configuration).

		If \meta{list} is not empty, it is expected to be a list of column names. Only these columns will be used as input for the transposition, just as if the remaining ones weren't there. It is acceptable to provide column aliases or |create on use| arguments inside of \meta{list}.
\begin{codeexample}[]
\pgfplotstabletranspose[columns={a,b}]\loadedtable{pgfplotstable.example3.dat}
\pgfplotstabletypeset[string type]\loadedtable
\end{codeexample}

		Here is the only difference between |\pgfplotstabletranspose| and |\pgfplotstabletranspose*|: the version without `|*|' \emph{resets} the |columns| key before it starts whereas the version with `|*|' simply uses the actual content of |columns|.
	\end{pgfplotskey}
\end{commandlist}

\begin{command}{\pgfplotstablesort\oarg{options}\meta{\textbackslash resulttable}\meta{\textbackslash table or filename}}
	Sorts \meta{\textbackslash table or filename} according to \meta{options} and writes the sorted table to \meta{\textbackslash resulttable}.

	Use the high level |sort| key to enable sorting automatically during |\pgfplotstabletypeset|.

\begin{codeexample}[]
\pgfplotstablesort[row sep=\\]\result{%
    a      b  c \\
    19     2 [a]\\
    -6   -14 [b]\\
     4   -14 [c]\\
   -11    -9 [d]\\
    11    14 [e]\\
    -9    -9 [f]\\
     1    13 [g]\\
     8   -10 [h]\\
    16    18 [i]\\
    19    -6 [j]\\
}
\pgfplotstabletypeset[columns/c/.style={string type}]{\result}%
\end{codeexample}
	
	The sort key and comparison function can be customized using the following keys:
	\begin{key}{/pgfplots/table/sort key=\marg{column} (initially [index]0)}
		Specifies the column which contains the sort key. The argument \meta{column} can be any of the columns of the input table, including |create on use|, |alias| or |[index]|\meta{integer} specifications. The initial setting uses the first available column.
	\end{key}
	\begin{key}{/pgfplots/table/sort key from=\marg{table} (initially empty)}
		Allows to load the |sort key| from a different \meta{table}, which can be either a \meta{\textbackslash macro} or a \meta{file name}.
	\end{key}

	\begin{key}{/pgfplots/table/sort cmp=\marg{less than routine} (initially float <)}
		Allows to use a different comparison function.
		\begin{pgfplotskeylist}{%
			fixed <,
			fixed >,
			int <,
			int >,
			float <,
			float >,
			date <,
			date >,
			string <,
			string >}
			These styles constitute the predefined comparison functions. The |fixed <|, |int <| and |float <| routines operate on numerical data where |int <| expects positive or negative integers and the other two expect real numbers. The |fixed <| has considerably smaller number range but is slightly faster than |float <|.

			The |date <| compares dates of the form |YYYY-MM-DD|. The |string <| uses lexicographical string comparison based on the ASCII character codes of the sort keys. The |string <| routine also evaluates ASCII codes of control sequences or active characters\footnote{As long as they haven't been consumed by \TeX's preprocessing.}.
\begin{codeexample}[]
\pgfplotstablesort[row sep=\\,sort cmp=string <]\result{%
	Header:\\% the column name
	the\\
	quick\\
	brown\\
	fox\\
	jumps\\
	over\\
	the\\
	lazy\\
	dog\\
}
\pgfplotstabletypeset[string type]{\result}%
\end{codeexample}
		\end{pgfplotskeylist}
		\begin{codeargskey}{/pgfplots/iflessthan}{#1#2#3#4}
			Allows to define custom comparison functions (a strict ordering). It compares |#1 < #2| and invokes |#3| in case the comparison is true and |#4| if not.
			The comparison will be evaluated in local scopes (local variables are freed afterwise).
		\end{codeargskey}
	\end{key}
\end{command}

\subsection{Repeating Things: Loops}
\begin{command}{\foreach \meta{variables} |in| \meta{list} \marg{commands}}
	A powerful loop command provided by \Tikz, see~\cite[Section Utilities]{tikz}.
\begin{codeexample}[]
\foreach \x in {1,2,...,4} {Iterating \x. }%
\end{codeexample}

	A \PGFPlots\ related example could be
\begin{codeexample}[code only]
\foreach \i in {1,2,...,10} {\addplot table {datafile\i}; }%
\end{codeexample}
\end{command}

\noindent The following loop commands come with \PGFPlots. They are similar to the powerful \Tikz\ |\foreach| loop command, which, however, is not always useful for table processing: the effect of its loop body end after each iteration.

The following \PGFPlots\ looping macros are an alternative.

\begin{command}{\pgfplotsforeachungrouped \meta{variable} |in| \meta{list} \marg{command}}
	A specialised variant of |\foreach| which can do two things: it does not introduce extra groups while executing \meta{command} and it allows to invoke the math parser for (simple!) \meta{$x_0$}|,|\meta{$x_1$}|,...,|\meta{$x_n$} expressions.

\begin{codeexample}[]
\def\allcollected{}
\pgfplotsforeachungrouped \x in {1,2,...,4} {Iterating \x. \edef\allcollected{\allcollected, \x}}%
All collected = \allcollected.
\end{codeexample}

	A more useful example might be to work with tables:

\begin{codeexample}[code only]
\pgfplotsforeachungrouped \i in {1,2,...,10} {%
	\pgfplotstablevertcat{\output}{datafile\i} % appends `datafile\i' -> `\output'
}%
% since it was ungrouped, \output is still defined (would not work
% with \foreach)
\end{codeexample}

	\paragraph{Remark: } The special syntax \meta{list}=\meta{$x_0$}|,|\meta{$x_1$}|,...,|\meta{$x_n$}, i.e.\ with two leading elements, followed by dots and a final element, invokes the math parser for the loop. Thus, it allows larger number ranges than any other syntax if |/pgf/fpu| is active.  In all other cases, |\pgfplotsforeachungrouped| invokes |\foreach| and provides the results without \TeX\ groups.
	
\end{command}

\begin{command}{\pgfplotsinvokeforeach\marg{list} \marg{command}}
	A variant of |\pgfplotsforeachungrouped| (and such also of |\foreach|) which replaces any occurence of |#1| inside of \meta{command} once for every element in \meta{list}. Thus, it actually assumes that \marg{command} is like a |\newcommand| body.

	In other words, \marg{command} is invoked for every element of \marg{list}. The actual element of \marg{list} is available as |#1|.

	As |\pgfplotsforeachungrouped|, this command does \emph{not} introduce extra scopes (i.e.\ it is ungrouped as well).

	The difference to |\foreach \x in |\meta{list}\marg{command} is subtle: the |\x| would \emph{not} be expanded wheres |#1| is. 
\begin{codeexample}[]
\pgfkeys{
  otherstyle a/.code={[a]},
  otherstyle b/.code={[b]},
  otherstyle c/.code={[c]},
  otherstyle d/.code={[d]}}
\pgfplotsinvokeforeach{a,b,c,d}        	
	{\pgfkeys{key #1/.style={otherstyle #1}}}
Invoke them: \pgfkeys{key a} \pgfkeys{key b} \pgfkeys{key c} \pgfkeys{key d}
\end{codeexample}
The counter example would use a macro (here |\x|) as loop argument:
\begin{codeexample}[]
\pgfkeys{
  otherstyle a/.code={[a]},
  otherstyle b/.code={[b]},
  otherstyle c/.code={[c]},
  otherstyle d/.code={[d]}}
\pgfplotsforeachungrouped \x in {a,b,c,d}        	
	{\pgfkeys{key \x/.style={otherstyle \x}}}
Invoke them: \pgfkeys{key a} \pgfkeys{key b} \pgfkeys{key c} \pgfkeys{key d}
\end{codeexample}

	\paragraph{Restrictions:} you can't nest this command yet (since it does not introduce protection by scopes).
\end{command}
\printindex

\bibliographystyle{abbrv} %gerapali} %gerabbrv} %gerunsrt.bst} %gerabbrv}% gerplain}
\bibliography{pgfplots}
\end{document}
